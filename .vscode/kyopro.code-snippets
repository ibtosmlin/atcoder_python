{
    "memo": {
        "prefix": [
            "memo_lru_cache"
        ],
        "body": [
            "from functools import lru_cache",
            "@lru_cache(1000000)"
        ],
        "description": [
            "memo"
        ],
        "scope": "python"
    },
    "collectionslib": {
        "prefix": [
            "from collections"
        ],
        "body": [
            "from collections import defaultdict",
            "from collections import deque",
            "from collections import Counter",
            ""
        ],
        "description": [
            "collectionslib"
        ],
        "scope": "python"
    },
    "heapqlib": {
        "prefix": [
            "from heapq"
        ],
        "body": [
            "from heapq import heappop, heappush"
        ],
        "description": [
            "heapqlib"
        ],
        "scope": "python"
    },
    "atcoder lib": {
        "prefix": [
            "from atcoder"
        ],
        "body": [
            "from atcoder.fenwicktree import FenwickTree",
            "from atcoder.dsu import DSU"
        ],
        "description": [
            "atcoder lib"
        ],
        "scope": "python"
    },
    "reverse=True": {
        "prefix": [
            "reverse=True"
        ],
        "body": [
            "reverse=True"
        ],
        "description": [
            "ソートでのリバース"
        ],
        "scope": "python"
    },
    "sort(key=itemgetter": {
        "prefix": [
            "sort(key=l"
        ],
        "body": [
            "sort(key=lambda x: x[1])"
        ],
        "description": [
            "itemgetterソート"
        ],
        "scope": "python"
    },
    "順列・組み合わせ": {
        "prefix": [
            "itertools",
            "Lib_順列・組み合わせ"
        ],
        "body": [
            "from itertools import *",
            "P = list(permutations(range($n), r))   # 順列(nPr)",
            "C = list(combinations(range($n), r))   # 組み合わせ(nCr)",
            "CR = list(combinations_with_replacement(range($n), r))  # 重複も許容した組み合わせ(nHr=n+r-1Cr)",
            "PN = list(product(range($n), repeat=r)) # 重複順列(n**r)",
            "T = [[1, 2],[3, 4, 5, 6],[7, 8, 9]]",
            "PT = list(product(*T))",
            "",
            "from more_itertools import distinct_combinations, distinct_permutations",
            ""
        ],
        "description": [
            "順列・組み合わせ"
        ],
        "scope": "python"
    },
    "direc": {
        "prefix": [
            "direc_canmove"
        ],
        "body": [
            "direc = {\"U\":(0, 1), \"R\":(1, 0), \"D\":(0, -1), \"L\":(-1, 0)}",
            "direc = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]",
            "",
            "def isin(i, j, H, W): return ~((0 <= i < H) and (0 <= j < W))",
            "def isnotin(i, j, H, W): return not isin(i, j, H, W)",
            "",
            "for di, dj in direc:",
            "    ni = i + di",
            "    nj = j + dj",
            ""
        ],
        "description": [
            "direc"
        ],
        "scope": "python"
    },
    "intinput": {
        "prefix": [
            "intinput"
        ],
        "body": [
            "int(input())"
        ],
        "description": [
            "int型でのinput"
        ],
        "scope": "python"
    },
    "inputsplit": {
        "prefix": [
            "inputsplit"
        ],
        "body": [
            "input().split()"
        ],
        "description": [
            "inputをsplit"
        ],
        "scope": "python"
    },
    "mapint": {
        "prefix": [
            "mapintinput"
        ],
        "body": [
            "map(int, input().split())"
        ],
        "description": [
            "int型で複数数値のinput"
        ],
        "scope": "python"
    },
    "mapint1": {
        "prefix": [
            "mapintinput1"
        ],
        "body": [
            "map(lambda x: int(x)-1, input().split())"
        ],
        "description": [
            "int型で複数数値の0-index input"
        ],
        "scope": "python"
    },
    "listmapint": {
        "prefix": [
            "listmapintinput"
        ],
        "body": [
            "list(map(int, input().split()))"
        ],
        "description": [
            "int型でlistのinput"
        ],
        "scope": "python"
    },
    "tuplemapint": {
        "prefix": [
            "tuplemapintinput"
        ],
        "body": [
            "tuple(map(int, input().split()))"
        ],
        "description": [
            "int型でtupleのinput"
        ],
        "scope": "python"
    },
    "matrixintinput": {
        "prefix": [
            "[listmapint"
        ],
        "body": [
            "[list(map(int, input().split())) for _ in range($N)"
        ],
        "description": [
            "int型でmatrixのinput"
        ],
        "scope": "python"
    },
    "matrixstrinput": {
        "prefix": [
            "[input()"
        ],
        "body": [
            "[list(input()) for _ in range($N)"
        ],
        "description": [
            "文字列でmatrixのinput"
        ],
        "scope": "python"
    },
    "n=intinput": {
        "prefix": [
            "nin"
        ],
        "body": [
            "N = int(input())"
        ],
        "description": [
            "整数nの読み込み"
        ],
        "scope": "python"
    },
    "nainput": {
        "prefix": [
            "nain"
        ],
        "body": [
            "N = int(input())",
            "A = list(map(int, input().split()))"
        ],
        "description": [
            "整数nの読み込み"
        ],
        "scope": "python"
    },
    "s=input": {
        "prefix": [
            "sin"
        ],
        "body": [
            "S = list(input())"
        ],
        "description": [
            "文字列sの読み込み"
        ],
        "scope": "python"
    },
    "n,m=map(int, input().split())": {
        "prefix": [
            "n, m=map"
        ],
        "body": [
            "N, M = map(int, input().split())"
        ],
        "description": [
            "整数n, mの読み込み"
        ],
        "scope": "python"
    },
    "a=list(map(int, input().split()))": {
        "prefix": [
            "a =list"
        ],
        "body": [
            "A = list(map(int, input().split()))"
        ],
        "description": [
            "リストの読み込み"
        ],
        "scope": "python"
    },
    "edges": {
        "prefix": [
            "G ="
        ],
        "body": [
            "G = [[] for _ in range($N)]",
            "for _ in range($M):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            ""
        ],
        "description": [
            "edges"
        ],
        "scope": "python"
    },
    "edgesweighted": {
        "prefix": [
            "G = w"
        ],
        "body": [
            "G = [[] for _ in range($N)]",
            "for _ in range($M):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            ""
        ],
        "description": [
            "edges(重み付き)"
        ],
        "scope": "python"
    },
    "0インデックス": {
        "prefix": [
            "a -= 1; b -= 1"
        ],
        "body": [
            "a -= 1; b -= 1"
        ],
        "description": [
            "0-indexed"
        ],
        "scope": "python"
    },
    "modval1": {
        "prefix": [
            "mod = 1000000007"
        ],
        "body": [
            "mod = 1000000007"
        ],
        "description": [
            "modval"
        ],
        "scope": "python"
    },
    "modval2": {
        "prefix": [
            "mod = 998244353"
        ],
        "body": [
            "mod = 998244353"
        ],
        "description": [
            "modval"
        ],
        "scope": "python"
    },
    "pival": {
        "prefix": [
            "pi_π円周率"
        ],
        "body": [
            "PI = 3.141592653589793"
        ],
        "description": [
            "pival"
        ],
        "scope": "python"
    },
    "alphabet": {
        "prefix": [
            "alphabet"
        ],
        "body": [
            "ALPS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; alps = 'abcdefghijklmnopqrstuvwxyz'",
            "def alp(i, base='a'): return chr(ord(base) + i%26)    # i=0->'a', i=25->'z'",
            "def alpind(a, base='a'): return ord(a)-ord(base)"
        ],
        "description": [
            "alphabet"
        ],
        "scope": "python"
    },
    "translate": {
        "prefix": [
            "translate",
            "replace"
        ],
        "body": [
            "s = '54IZSB'",
            "ts = s.translate(str.maketrans(\"BSI\",\"123\"))",
            "print(ts)",
            "# 543Z21"
        ],
        "description": [
            "複数の文字列を変換"
        ],
        "scope": "python"
    },
    "d進数": {
        "prefix": [
            "n進数",
            "d進数"
        ],
        "body": [
            "##############################",
            "# nをd進数表記",
            "# d進数表記を10進数表記に",
            "##############################",
            "",
            "n = 32",
            "",
            "print(format(n, 'b'))  # ２進数",
            "print(format(n, 'o'))  # ８進数",
            "print(format(n, 'x'))  # 16進数",
            "",
            "print(bin(n))  # ２進数",
            "print(oct(n))  # ８進数",
            "print(hex(n))  # 16進数",
            "",
            "# 任意のd進数",
            "def base_repr(n:int, d:int) -> str:",
            "    ret = ''",
            "    while n != 0:",
            "        n, r = divmod(n, d)",
            "        ret += str(r)",
            "    return ret[::-1]",
            "",
            "print(base_repr(n, 2))",
            "print(base_repr(n, 30))",
            "",
            "",
            "##############################",
            "# d進数表記を10進数表記に",
            "##############################",
            "s = '12'",
            "d = 9",
            "print(int(s, base=d))",
            "",
            "# 関数版",
            "def myint(s:str, d:int) -> int:",
            "    ret = 0",
            "    dig = 1",
            "    for xi in s[::-1]:",
            "        ret += int(xi)*dig",
            "        dig *= d",
            "    return ret",
            "",
            "print(myint(s, 9))",
            ""
        ],
        "description": [
            "nをd進数表記"
        ],
        "scope": "python"
    },
    "digital digit": {
        "prefix": [
            "digital digit"
        ],
        "body": [
            "led_statuses = [\"1110111\", \"0100100\", \"1011101\", \"1101101\", \"0101110\",",
            "    \"1101011\", \"1111011\", \"0100111\", \"1111111\", \"1101111\"]",
            "led_digit = [int(status, base=2) for status in led_statuses]"
        ],
        "description": [
            " -",
            "| |",
            " -",
            "| |",
            " -",
            ""
        ],
        "scope": "python"
    },
    "Lib_math": {
        "prefix": [
            "Lib_math_最大公約数_三角関数",
            "import math"
        ],
        "body": [
            "import math",
            "print(math.sin(math.pi/4))",
            "print(math.cos(math.pi/4))",
            "print(math.tan(math.pi/4))",
            "# 度→radian",
            "math.radians(180)",
            "# radian→度",
            "math.degrees(3.1415)",
            ""
        ],
        "description": [
            "mathのライブラリ"
        ],
        "scope": "python"
    },
    "Lib_decimal": {
        "prefix": [
            "Lib_四捨五入_Decimal"
        ],
        "body": [
            "",
            "pypyで使っちゃダメ！！！！！",
            "from decimal import Decimal",
            "x, y, r = map(Decimal, input().split())",
            "f = 123.456",
            "fd = Decimal(str(f))",
            "fr = fd.quantize(Decimal('0'), rounding=ROUND_HALF_UP)  #123",
            "fr = fd.quantize(Decimal('0.1'), rounding=ROUND_HALF_UP)#123.5"
        ],
        "description": [
            "四捨五入が正しくできるツール",
            "Decimal で扱う"
        ],
        "scope": "python"
    },
    "Lib_math_複素数": {
        "prefix": [
            "Lib_math_複素数"
        ],
        "body": [
            "import cmath",
            "",
            "z1 = 5 + 13j",
            "a, b = 5, 13",
            "z2 = complex(a, b)",
            "",
            "print(z1.real)",
            "print(z1.imag)",
            "",
            "",
            "# 極座標表示",
            "r, theta = cmath.polar(z1)",
            "",
            "# 90度回転",
            "print(cmath.rect(1, cmath.pi/2))",
            "# (6.123233995736766e-17+1j)",
            "",
            "# 共役数",
            "print(z2.conjugate())",
            "# (5-13j)",
            ""
        ],
        "description": [
            "Lib_複素数"
        ],
        "scope": "python"
    },
    "Lib_sort_by_function": {
        "prefix": [
            "Lib_sort_by_function比較"
        ],
        "body": [
            "",
            "# https://atcoder.jp/contests/abc308/tasks/abc308_c",
            "",
            "class OrderedObj:",
            "    def __init__(self, x):",
            "        self.a, self.b, self.i = x",
            "",
            "    def __lt__(self, other):",
            "        # 小さい＞True",
            "        if self.a * (other.a+other.b) < other.a * (self.a+self.b):",
            "            return True",
            "        if self.i > other.i:",
            "            return True",
            "        return False",
            "",
            "    def __repr__(self):",
            "        return f'{self.a} {self.b} {self.i}'",
            "",
            ""
        ],
        "description": [
            "Lib_sort_by_function"
        ],
        "scope": "python"
    },
    "Lib_sqroot": {
        "prefix": [
            "Lib_sqroot"
        ],
        "body": [
            "def sqrt(x):",
            "    r = int(x**0.5) - 3",
            "    while (r+1)*(r+1) <= x: r += 1",
            "    return r"
        ],
        "description": [
            "Lib_sqroot"
        ],
        "scope": "python"
    },
    "BITset": {
        "prefix": [
            "Lib_BITSET"
        ],
        "body": [
            "",
            "def popcount64(n):",
            "    c=(n&0x5555555555555555)+((n>>1)&0x5555555555555555)",
            "    c=(c&0x3333333333333333)+((c>>2)&0x3333333333333333)",
            "    c=(c&0x0f0f0f0f0f0f0f0f)+((c>>4)&0x0f0f0f0f0f0f0f0f)",
            "    c=(c&0x00ff00ff00ff00ff)+((c>>8)&0x00ff00ff00ff00ff)",
            "    c=(c&0x0000ffff0000ffff)+((c>>16)&0x0000ffff0000ffff)",
            "    c=(c&0x00000000ffffffff)+((c>>32)&0x00000000ffffffff)",
            "    return c",
            "",
            "def bitset(s, b, m):",
            "    \"\"\"",
            "        sをbビットずつ下からm個に区切る",
            "    \"\"\"",
            "    s = list(map(int, s))",
            "    ret = [0] * m",
            "    s = [0] * (b*m - len(s)) + s",
            "    for i in range(m):",
            "        bit = 0",
            "        for j in range(b):",
            "            bit |= s[i * b + j] << j",
            "        ret[i] = bit",
            "    return ret",
            "",
            "# https://atcoder.jp/contests/abc258/tasks/abc258_g",
            ""
        ],
        "description": [
            "BITset"
        ],
        "scope": "python"
    },
    "BIT演算": {
        "prefix": [
            "Lib_BIT演算"
        ],
        "body": [
            "",
            "class Bit:",
            "    def __init__(self, x=0):",
            "        self.x = int(x)",
            "",
            "    def __bool__(self):",
            "        return self.x != 0",
            "",
            "    def __int__(self):",
            "        return self.x",
            "",
            "    def __str__(self):",
            "        return f'int: {self.x} bin: {self.bin()}'",
            "",
            "    @property",
            "    def len(self):",
            "        return self.x.bit_length()",
            "",
            "    @property",
            "    def bitcount(self):",
            "        return bin(self.x).count('1')",
            "",
            "    def bin(self, l=32):",
            "        return ('0' * l + bin(self.x)[2:])[-l:]",
            "",
            "    def getkthbit(self, k):",
            "        \"\"\"kビット目を取得",
            "        \"\"\"",
            "        return Bit(self.x & (1 << k))",
            "",
            "    def isbitk(self, k):",
            "        return self.getkthbit(k).__bool__()",
            "",
            "    def onkthbit(self, k):",
            "        \"\"\"kビット目を１にした値",
            "        \"\"\"",
            "        return Bit(self.x | (1 << k))",
            "",
            "    def offkthbit(self, k):",
            "        \"\"\"kビット目を０にした値",
            "        \"\"\"",
            "        return Bit(self.x & ~(1 << k))",
            "",
            "    def invertkthbit(self, k):",
            "        \"\"\"kビット目を反転させた値",
            "        \"\"\"",
            "        return Bit(self.x ^ (1 << k))",
            "",
            "    def invert(self):",
            "        \"\"\"全ビット目を反転させた値",
            "        \"\"\"",
            "        return Bit(~self.x)",
            "",
            "",
            "    def subset(self)->list:",
            "        \"\"\"集合xの部分集合を列挙",
            "        \"\"\"",
            "        v = (-1) & self.x",
            "        ret = []",
            "        while v:",
            "            ret.append(Bit(v))",
            "            v = (v - 1) & self.x",
            "        return ret",
            "",
            "    def kcountsubset(self, k)->list:",
            "        \"\"\"x以下の部分集合でビットがk個のものを列挙",
            "        \"\"\"",
            "        ret = []",
            "        v = (1 << k) - 1",
            "        while v < self.x:",
            "            ret.append(Bit(v))",
            "            x = v & -v; y = v + x",
            "            v = ((v & ~y) // x >> 1) | y",
            "        return ret",
            "",
            "",
            "",
            "x = Bit(7)",
            "print(x)",
            "print(x.onkthbit(0))",
            "print(x.offkthbit(0))",
            "print(x.invertkthbit(0))",
            "print(x.invert())",
            "print(x.isbitk(0))",
            "print(x.isbitk(1))",
            "print(x.isbitk(2))",
            "print(x.isbitk(3))",
            "print(x.isbitk(4))",
            "",
            "for b in x.subset():",
            "    print(b)",
            "print(\"--\")",
            "for b in x.kcountsubset(2):",
            "    print(b)",
            "",
            "",
            "# https://qiita.com/qiita_kuru/items/3a6ab432ffb6ae506758",
            "",
            "# 111",
            "~((~0)<<3)      # 111",
            "(1 << 3) - 1    # 111",
            "",
            ""
        ],
        "description": [
            "BIT演算"
        ],
        "scope": "python"
    },
    "output0": {
        "prefix": [
            "print(0ret)"
        ],
        "body": [
            "print($ret)"
        ],
        "description": [
            "print(ret)"
        ],
        "scope": "python"
    },
    "output2": {
        "prefix": [
            "print(2INF⇒-1)"
        ],
        "body": [
            "ret =",
            "print(-1 if $ret == INF else $ret)"
        ],
        "description": [
            "print(INF⇒-1)"
        ],
        "scope": "python"
    },
    "output3": {
        "prefix": [
            "print(3'\\n'.join(map(str)"
        ],
        "body": [
            "print('\\n'.join(map(str, $ret)))"
        ],
        "description": [
            "print(3'\\n'.join(map)"
        ],
        "scope": "python"
    },
    "output4": {
        "prefix": [
            "print(4''.join(ret))"
        ],
        "body": [
            "print(''.join($ret))"
        ],
        "description": [
            "print(\"\".join)"
        ],
        "scope": "python"
    },
    "output interactive": {
        "prefix": [
            "print(6interactive)"
        ],
        "body": [
            "def req($ret): print($ret, flush=True)",
            ""
        ],
        "description": [
            "interactive"
        ],
        "scope": "python"
    },
    "output7": {
        "prefix": [
            "print(7roundeds)"
        ],
        "body": [
            "def fstr(x): return f'{x:.10f}'",
            ""
        ],
        "description": [
            "rounded"
        ],
        "scope": "python"
    },
    "outputYesNo": {
        "prefix": [
            "print(5yesno)"
        ],
        "body": [
            "ret =",
            "print('Yes' if $ret else 'No')"
        ],
        "description": [
            "outputYesNo"
        ],
        "scope": "python"
    },
    "偏角ソート": {
        "prefix": [
            "Lib_AL_偏角ソート"
        ],
        "body": [
            "from functools import cmp_to_key",
            "def degree_sort(points):",
            "    def quadrant(x, y):",
            "        if x == 0 and y == 0: return 0",
            "        if x >= 0 and y >= 0: return 1",
            "        if x <= 0 and y >= 0: return 2",
            "        if x <= 0 and y <= 0: return 3",
            "        if x >= 0 and y <= 0: return 4",
            "",
            "    def points_cmp(p, q):",
            "        p_qua = quadrant(*p)",
            "        q_que = quadrant(*q)",
            "        if p_qua == q_que:",
            "            px, py = p",
            "            qx, qy = q",
            "            op = px * qy - py * qx",
            "            return -1 if op > 0 else 1 if op < 0 else 0",
            "        else:",
            "            return -1 if p_qua < q_que else 1",
            "    return sorted(points, key = cmp_to_key(points_cmp))",
            "########################################"
        ],
        "description": [
            "偏角ソート"
        ],
        "scope": "python"
    },
    "Lib_AL_図形_三角形_角度": {
        "prefix": [
            "Lib_AL_図形_三角形_角度"
        ],
        "body": [
            "",
            "########################",
            "import math",
            "",
            "# 度→radian",
            "math.radians(180)",
            "# radian→度",
            "math.degrees(3.1415)",
            "########################",
            "# 三角形",
            "########################",
            "# 余弦定理",
            "# cosR = (a**2 + b**2 - c**2) / 2ab",
            "# c**2 = a**2 + b**2 - 2*a*b*cosR",
            "# 対辺",
            "def C(a, b, R):",
            "    \"\"\"",
            "    a, b: 二辺の長さ",
            "    R: 角度",
            "    Returns",
            "    対辺の長さ",
            "    \"\"\"",
            "    R = math.radians(R)  # Rが度数の場合",
            "    return (a ** 2 + b** 2 - 2 * a * b * math.cos(R))**0.5",
            "",
            "def S(a, b, R):",
            "    \"\"\"",
            "    a, b: 二辺の長さ",
            "    R: 角度",
            "    Returns",
            "    面積",
            "    \"\"\"",
            "    R = math.radians(R)  # Rが度数の場合",
            "    return abs(0.5 * a * b * math.sin(R))",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ],
        "scope": "python"
    },
    "Lib_AL_図形_n角形/円": {
        "prefix": [
            "Lib_AL_図形_n角形/円"
        ],
        "body": [
            "",
            "import math",
            "EPS = 1e-08",
            "MAX = 2e09",
            "PI = math.pi",
            "",
            "######################################################################",
            "class Point:",
            "    def __init__(self, x=0, y=0):",
            "        self.x = x",
            "        self.y = y",
            "",
            "    def __add__(self, other):",
            "        return Point(self.x + other.x, self.y + other.y)",
            "",
            "    def __sub__(self, other):",
            "        return Point(self.x - other.x, self.y - other.y)",
            "",
            "    def __mul__(self, const):",
            "        return Point(self.x * const, self.y * const)",
            "",
            "    def __truediv__(self, const):",
            "        return Point(self.x / const, self.y / const)",
            "",
            "    def __eq__(self, other):",
            "        return (self - other).norm2 < EPS",
            "",
            "    @property",
            "    def norm2(self):",
            "        return self.x **2 + self.y **2",
            "",
            "    @property",
            "    def abs(self):",
            "        return self.norm2 ** 0.5",
            "",
            "    @property",
            "    def radian(self):",
            "        return math.atan2(self.y, self.x)",
            "",
            "    @property",
            "    def quadrant(self):",
            "        if self.x == 0 and self.y == 0: return 0",
            "        if self.x > 0 and self.y >= 0: return 1",
            "        if self.x <= 0 and self.y > 0: return 2",
            "        if self.x < 0 and self.y <= 0: return 3",
            "        return 4",
            "",
            "    def dot(self, other):",
            "        return self.x * other.x + self.y * other.y",
            "",
            "    def det(self, other):",
            "        return self.x * other.y - self.y * other.x",
            "",
            "    def dot3(self, other1, other2):",
            "        return (other1 - self).dot(other2 - self)",
            "",
            "    def det3(self, other1, other2):",
            "        return (other1 - self).det(other2 - self)",
            "",
            "    def dist2(self, other):",
            "        d = self - other",
            "        return (d.x)**2 + (d.y)**2",
            "",
            "    def dist(self, other):",
            "        return self.dist2(other) ** 0.5",
            "",
            "    def __lt__(self, other):",
            "        seq = self.quadrant",
            "        otq = other.quadrant",
            "        det = self.det(other)",
            "        if seq != otq:",
            "            return seq < otq",
            "        if det == 0:",
            "            return self.norm2 < other.norm2",
            "        else:",
            "            return det > 0",
            "",
            "    def rotate_radian(self, rad):",
            "        cos, sin = math.cos(rad), math.sin(rad)",
            "        return Point(self.x * cos - self.y * sin, self.x * sin + self.y * cos)",
            "",
            "    def rotate_degree(self, rad):",
            "        rad = math.radians(rad)  # radが度数の場合",
            "        return self.rotate_radian(rad)",
            "",
            "    @property",
            "    def orthogonal(self):",
            "        return Point(- self.y, self.x)",
            "",
            "    def counter_clockwise(self, other1, other2):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C",
            "        COUNTER_CLOCKWISE = 1   #左に曲がる場合(1)",
            "        CLOCKWISE = -1          #右に曲がる場合(2)",
            "        ONLINE_BACK = 2         #c<-a->b 反対に戻る(3)",
            "        ONLINE_FRONT = -2       #a->b->c 同じ方向に伸びる(4)",
            "        ON_SEGMENT = 0          #a->c->b 戻るがaとbの間(5)",
            "    ###################################################################",
            "        a, b, c = self, other1, other2",
            "        ba, ca = b - a, c - a",
            "        det = b.det(c)",
            "        if det > EPS: return COUNTER_CLOCKWISE",
            "        if det < -EPS: return CLOCKWISE",
            "        if ba.dot(ca) < -EPS: return ONLINE_BACK",
            "        if (a - b).dot(c - b) < -EPS: return ONLINE_FRONT",
            "        return ON_SEGMENT",
            "",
            "    @property",
            "    def value(self):",
            "        return self.x, self.y",
            "",
            "",
            "######################################################################",
            "class Line:",
            "    \"\"\"基本は線分\"\"\"",
            "    def __init__(self, p0: Point, p1: Point):",
            "        self.p0, self.p1 = p0, p1",
            "        self.vector = p1 - p0",
            "",
            "    @property",
            "    def mid_point(self):",
            "    # 中点",
            "        return self.p0 + self.vector * 0.5",
            "",
            "    @property",
            "    def midperpendicular(self):",
            "    # 垂直二等分線",
            "    # 中点から中点＋直交ベクトルまでの線分とする",
            "        return Line(self.mid_point, self.mid_point + self.vector.orthogonal)",
            "",
            "    def is_parallel(self, other):",
            "    #https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A",
            "    # ２直線の平行判定",
            "        return abs(self.vector.det(other.vector)) < EPS",
            "",
            "    def is_orthogonal(self, other):",
            "    #https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A",
            "    # ２直線の直交判定",
            "        return abs(self.vector.dot(other.vector)) < EPS",
            "",
            "    def project(self, p: Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A",
            "    # 垂線の足",
            "        dv = self.p0.dot3(self.p1, p)",
            "        dd = self.p0.dist2(self.p1)",
            "        return self.p0 + self.vector * (dv/dd)",
            "",
            "    def dist_from_point_to_project(self, p: Point):",
            "        # 垂線の長さ",
            "        return p.dist2(self.project(p)) ** 0.5",
            "",
            "    def dist_from_point(self, p: Point):",
            "        # 線分としての点からの距離",
            "        dv = self.p0.dot3(self.p1, p)",
            "        dd = self.p0.dist2(self.p1)",
            "        if 0 <= dv <= dd:",
            "            return p.dist2(self.project(p)) ** 0.5",
            "        else:",
            "            return min(self.p0.dist(p), self.p1.dist(p))",
            "",
            "    def reflect(self, p: Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B",
            "    # 反射",
            "        return p + (self.project(p) - p) * 2",
            "",
            "    def is_intersect(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B",
            "    # 線分同士の交点判定",
            "        p0, p1 = self.p0, self.p1",
            "        q0, q1 = other.p0, other.p1",
            "        C0, C1 = p0.det3(p1, q0), p0.det3(p1, q1)",
            "        D0, D1 = q0.det3(q1, p0), q0.det3(q1, p1)",
            "        if abs(C0) < EPS and abs(C1) < EPS:",
            "            E0, E1 = p0.dot3(p1, q0), p0.dot3(p1, q1)",
            "            if not E1 - E0 > 0:",
            "                E0, E1 = E1, E0",
            "            return p0.dist2(p1) - E0 > -EPS and E1 > -EPS",
            "        return C0 * C1 < EPS and D0* D1 < EPS",
            "",
            "    def cross_point(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C",
            "    # 線分(直線含む)の交点",
            "        if self.is_parallel(other): return None",
            "        d = self.vector.det(other.vector)",
            "        sn = (other.p0 - self.p0).det(other.vector)",
            "        return self.p0 + self.vector * (sn/d)",
            "",
            "    def dist_to_line(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D",
            "    # 線分と線分の距離",
            "        if self.is_intersect(other):",
            "            return 0",
            "        ret = float('inf')",
            "        h = other.project(self.p0)",
            "        if other.p0.counter_clockwise(other.p1, h) == 0:",
            "            ret = min(ret, self.p0.dist(h))",
            "        h = other.project(self.p1)",
            "        if other.p0.counter_clockwise(other.p1, h) == 0:",
            "            ret = min(ret, self.p1.dist(h))",
            "        h = self.project(other.p0)",
            "        if self.p0.counter_clockwise(self.p1, h) == 0:",
            "            ret = min(ret, other.p0.dist(h))",
            "        h = self.project(other.p1)",
            "        if self.p0.counter_clockwise(self.p1, h) == 0:",
            "            ret = min(ret, other.p1.dist(h))",
            "        ret = min(ret, self.p0.dist(other.p0), self.p0.dist(other.p1))",
            "        ret = min(ret, self.p1.dist(other.p0), self.p1.dist(other.p1))",
            "        return ret",
            "",
            "    def half_line(self, reverse=False):",
            "    # 半直線",
            "        d = self.vector.abs",
            "        if reverse:",
            "            return Line(self.p0, self.p0 + self.vector * MAX / d)",
            "        return Line(self.p0 - self.vector * MAX / d, self.p1)",
            "",
            "    def line(self):",
            "    # 直線",
            "        d = self.vector.abs",
            "        return Line(self.p0 - self.vector * MAX / d, self.p0 + self.vector * MAX / d)",
            "",
            "    @property",
            "    def value(self):",
            "        return self.p0.value, self.p1.value, self.vector",
            "",
            "    def contains(self, p: Point):",
            "        return self.p0.counter_clockwise(self.p1, p) == 0",
            "",
            "",
            "######################################################################",
            "class Polygon:",
            "    def __init__(self, pts: list):",
            "        # pts = [Point(x, y) for x, y in listoftuple]",
            "        self.N = len(pts)",
            "        self.points = pts",
            "        self.pts = [p.value for p in pts]",
            "",
            "    def __len__(self, other):",
            "        return self.N",
            "",
            "    def sort(self):",
            "        if self.N == 0: return",
            "        p0 = sorted(self.points)[0]",
            "        points = [q + p0 for q in sorted([p - p0 for p in self.points])]",
            "        self.points = points",
            "        self.pts = [p.value for p in points]",
            "",
            "    @property",
            "    def value(self):",
            "        return self.pts",
            "",
            "    @property",
            "    def area(self):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A",
            "    # 多角形の面積",
            "    # O(N)",
            "        P = self.points",
            "        return abs(sum(P[i].det(P[i-1]) for i in range(self.N))) / 2",
            "",
            "    @property",
            "    def is_convex(self):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B",
            "    # 凸性判定",
            "    # O(N)",
            "        P = self.points",
            "        return not any((P[i-2].counter_clockwise(P[i-1], P[i]) == -1 for i in range(self.N)))",
            "",
            "    def contains(self, p:Point, isconvex=True):",
            "        \"\"\"",
            "        returns",
            "        0: not",
            "        1: on 線上",
            "        2: contain 包含",
            "        \"\"\"",
            "        ON_EDGE = 1",
            "        INCLUDE = 2",
            "        NOT_INCLUDE = 0",
            "        if isconvex:",
            "            return self._contains_convex(p)",
            "        else:",
            "            return self._contains_notconvex(p)",
            "",
            "    def _contains_notconvex(self, p:Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C",
            "    # 多角形-点の包含 凸多角形とは限らない",
            "    # O(N)",
            "        \"\"\"",
            "        returns",
            "        0: not",
            "        1: on 線上",
            "        2: contain 包含",
            "        \"\"\"",
            "        ON_EDGE = 1",
            "        INCLUDE = 2",
            "        NOT_INCLUDE = 0",
            "        included = False",
            "        for i in range(self.N):",
            "            p0, p1 = self.points[i-1] - p, self.points[i] - p",
            "            if abs(p0.det(p1)) < EPS and p0.dot(p1) < EPS: return ON_EDGE",
            "            if p0.y > p1.y: p0, p1 = p1, p0",
            "            if p0.y < EPS < p1.y and p0.det(p1) > EPS: included = not included",
            "        if included: return INCLUDE",
            "        return NOT_INCLUDE",
            "",
            "",
            "    def _contains_convex(self, p: Point):",
            "        # https://atcoder.jp/contests/abc296/tasks/abc296_g",
            "        # ある点が凸多角形に入っているか",
            "        # log(N)",
            "        ON_EDGE = 1",
            "        INCLUDE = 2",
            "        NOT_INCLUDE = 0",
            "        ######################",
            "        left = 1; right = self.N",
            "        q0 = self.points[0]",
            "        while right - left > 1:",
            "            mid = (left + right) // 2",
            "            if q0.det3(p, self.points[mid]) < EPS: left = mid",
            "            else: right = mid",
            "        if left == self.N-1:",
            "            left -= 1",
            "        qi = self.points[left]; qj = self.points[left + 1]",
            "        v0 = q0.det3(qi, qj)",
            "        v1, v2 = q0.det3(p, qj), q0.det3(qi, p)",
            "        if v0 < -EPS:",
            "            v1 = -v1; v2 = -v2",
            "        if 0 <= v1 and 0 <= v2 and v1 + v2 <= v0:",
            "            if left == 1 and abs(v2) < EPS: return ON_EDGE",
            "            if left + 1 == self.N - 1 and abs(v1) < EPS: return ON_EDGE",
            "            if abs(v1 + v2 - v0) < EPS: return ON_EDGE",
            "            return INCLUDE",
            "        return NOT_INCLUDE",
            "",
            "    @property",
            "    def convex_hull(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/problems/CGL_4_A",
            "        # ps = [(x, y), ...]",
            "        # 凸包(点集合 P の全ての点を含む最小の凸多角形)を出力する",
            "        # O(N)",
            "        _pts = sorted(self.pts)",
            "        qs = []",
            "        N = len(_pts)",
            "        for x, y in _pts:",
            "            p = Point(x, y)",
            "            while len(qs) > 1 and qs[-1].det3(qs[-2], p) > EPS:",
            "                qs.pop()",
            "            qs.append(p)",
            "        t = len(qs)",
            "        for i in range(N-1)[::-1]:",
            "            x, y = _pts[i]",
            "            p = Point(x, y)",
            "            while len(qs) > t and qs[-1].det3(qs[-2], p) > EPS:",
            "                qs.pop()",
            "            qs.append(p)",
            "        return Polygon(qs[:-1])",
            "",
            "    @property",
            "    def diameter(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B",
            "        # 凸多角形の直径",
            "        # O(N)",
            "        ch = self.convex_hull",
            "        if ch.N == 2:",
            "            return ch.points[0].dist(ch.points[1])",
            "        i = j = 0",
            "        for k in range(ch.N):",
            "            if ch.points[k].value < ch.points[i].value: i = k",
            "            if ch.points[j].value < ch.points[k].value: j = k",
            "        ret = 0",
            "        si = i; sj = j",
            "        while i != sj or j != si:",
            "            ret = max(ret, ch.points[i].dist(ch.points[j]))",
            "            if (ch.points[i]-ch.points[i-ch.N+1]).det(ch.points[j]-ch.points[j-ch.N+1])  < -EPS:",
            "                i = (i+1) % ch.N",
            "            else:",
            "                j = (j+1) % ch.N",
            "        return ret",
            "",
            "    def convex_cut(self, l: Line):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C",
            "        # 凸多角形を直線で切った時の右側の多角形",
            "        q = []",
            "        for i in range(self.N):",
            "            p0, p1 = self.points[i-1], self.points[i]",
            "            cv0, cv1 = l.p0.det3(l.p1, p0), l.p0.det3(l.p1, p1)",
            "            if cv0 * cv1 < EPS:",
            "                v = l.cross_point(Line(p0, p1))",
            "                if v is not None: q.append(v)",
            "            if cv1 > -EPS: q.append(p1)",
            "        return Polygon(q)",
            "",
            "    def intersection(self, other):",
            "        sps = self.points",
            "        ops = other.points",
            "        points = []",
            "        for p in sps:",
            "            if other.contains(p): points.append(p)",
            "        for p in ops:",
            "            if self.contains(p): points.append(p)",
            "",
            "        for i in range(self.N):",
            "            p0, p1 = sps[i-1], sps[i]",
            "            self_line = Line(p0, p1)",
            "            for j in range(other.N):",
            "                q0, q1 = ops[j-1], ops[j]",
            "                other_line = Line(q0, q1)",
            "                if self_line.is_intersect(other_line):",
            "                    p = self_line.cross_point(other_line)",
            "                    if p: points.append(p)",
            "        points.sort()",
            "        sub = []",
            "        for i in range(len(points)):",
            "            if points[i-1] != points[i]:",
            "                sub.append(points[i-1])",
            "        inter = Polygon(sub)",
            "        inter.sort()",
            "        return inter",
            "",
            "######################################################################",
            "class Circle:",
            "    def __init__(self, p: Point, r: float):",
            "        self.center = p",
            "        self.radius = r",
            "",
            "    @property",
            "    def value(self):",
            "        return self.center, self.radius",
            "",
            "    @property",
            "    def area(self):",
            "        return PI * self.radius * self.radius",
            "",
            "    def area_sector(self, rad):",
            "        return self.radius * self.radius * rad / 2",
            "",
            "    def contain_point(self, p:Point):",
            "        return (p - self.center).abs - self.radius < -EPS",
            "",
            "    def is_intersect(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A",
            "    # 円の交差判定",
            "    # 接線の数を出力",
            "        OUTER = 4           # 離れている",
            "        CIRCUMSCRIBED = 3   # 外接",
            "        CROSSED = 2           # 交わる",
            "        INSCRIBED = 1       # 内接",
            "        CONTAINED = 0         # 包含",
            "",
            "        R = max(self.radius, other.radius)",
            "        r = min(self.radius, other.radius)",
            "        d = self.center.dist(other.center)",
            "        # d > R+r :O o | d < R-r: ◎ | else 交差",
            "        if d - R - r > EPS: return OUTER",
            "        elif d - R - r > -EPS : return CIRCUMSCRIBED",
            "        if R - r - d > EPS: return CONTAINED",
            "        elif R - r -d > -EPS: return INSCRIBED",
            "        return CROSSED",
            "",
            "    def cross_point_line(self, l: Line, restrict=False):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D",
            "        # 直線との交点",
            "        # restrict == True なら線分として判定",
            "        p0c = l.p0 - self.center",
            "        a = l.vector.abs ** 2",
            "        b = l.vector.dot(p0c)",
            "        c = p0c.abs ** 2 - self.radius ** 2",
            "        D = b**2 - a * c",
            "        if D < -EPS: return (None, None)",
            "        if D < EPS: D = 0",
            "        s1 = (- b + D**0.5) / a",
            "        p1 = l.p0 + l.vector * s1",
            "        s2 = (- b - D**0.5) / a",
            "        p2 = l.p0 + l.vector * s2",
            "        if restrict:",
            "            if not (0 <= s1 <= 1): p1 = None",
            "            if not (0 <= s2 <= 1): p2 = None",
            "        return (p1, p2)",
            "",
            "    def cross_point_circle(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E",
            "        # 円同士の交点",
            "        isintersect = self.is_intersect(other)",
            "        if isintersect == 0 or isintersect == 4: return (None, None)",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        rr1 = self.radius ** 2",
            "        rr2 = other.radius ** 2",
            "        cv = rr0 + rr1 - rr2",
            "        sv = (4*rr0*rr1 - cv**2)**0.5",
            "        p1 = (d * cv + d.orthogonal * sv) / (2 * rr0)",
            "        p1 = self.center + p1",
            "        p2 = (d * cv - d.orthogonal * sv) / (2 * rr0)",
            "        p2 = self.center + p2",
            "        return (p1, p2)",
            "",
            "    def sector_area(self, p1: Point, p2: Point):",
            "        # 円弧の面積",
            "        rad = abs((p1-self.center).radian - (p2-self.center).radian)",
            "        mrad = min(rad, 2*PI - rad)",
            "        Mrad = max(rad, 2*PI - rad)",
            "        return self.area_sector(mrad), self.area_sector(Mrad)",
            "",
            "    def cross_area_line(self, l:Line):",
            "        # 円を直線で切った部分の面積",
            "        tri = Triangle([self.center, l.p0, l.p1]).area",
            "        sector = self.sector_area(l.p0, l.p1)",
            "        return (sector[0] - tri, sector[1] + tri)",
            "",
            "    def cross_area_circle(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_I",
            "        # ２つ円の共通部分の面積",
            "        isintersect = self.is_intersect(other)",
            "        if isintersect >= 3: return 0",
            "        if isintersect < 2: return min(self.area, other.area)",
            "        dd = (self.center - other.center).norm2",
            "        p1 = self.radius ** 2 - other.radius ** 2 + dd",
            "        p2 = other.radius ** 2 - self.radius ** 2 + dd",
            "        S1 = self.radius * self.radius * math.atan2((4 * dd * self.radius ** 2 - p1 ** 2) ** 0.5, p1)",
            "        S2 = other.radius * other.radius * math.atan2((4 * dd * other.radius ** 2 - p2 ** 2) ** 0.5, p2)",
            "        S0 = (4 * dd * self.radius * self.radius - p1 ** 2) ** 0.5 / 2",
            "        return S1 + S2 - S0",
            "",
            "    def tangent_point(self, p:Point):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F",
            "        # 円と点の接点",
            "        if self.contain_point(p): return None",
            "        r = ((self.center - p).abs ** 2 - self.radius ** 2) ** 0.5",
            "        dummycircle = Circle(p, r)",
            "        return self.cross_point_circle(dummycircle)",
            "",
            "    def tangent_line(self, p:Point):",
            "        # 円と点の接線",
            "        return Line(p, self.tangent_point)",
            "",
            "    def common_tanget_outer(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G",
            "        # 円と円の共通接線の外接点",
            "        retext = []",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        cv  = self.radius - other.radius",
            "        sv = rr0 - cv ** 2",
            "        if sv > -EPS:",
            "        ## 外接線",
            "            if abs(sv) < EPS:",
            "                retext.append(self.center + d * (self.radius * cv / rr0))",
            "            else:",
            "                sv **= 0.5",
            "                retext.append(self.center + (d * cv + d.orthogonal * sv) * self.radius / rr0)",
            "                retext.append(self.center + (d * cv - d.orthogonal * sv) * self.radius / rr0)",
            "        return retext",
            "",
            "    def common_tanget_inner(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G",
            "        # 円と円の共通接線の内接点",
            "        retext = []",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        cv  = self.radius + other.radius",
            "        sv = rr0 - cv ** 2",
            "        if sv > -EPS:",
            "        ## 内接線",
            "            if abs(sv) < EPS:",
            "                retext.append(self.center + d * (self.radius * cv / rr0))",
            "            else:",
            "                sv **= 0.5",
            "                retext.append(self.center + (d * cv + d.orthogonal * sv) * self.radius / rr0)",
            "                retext.append(self.center + (d * cv - d.orthogonal * sv) * self.radius / rr0)",
            "        return retext",
            "",
            "",
            "######################################################################",
            "class Triangle(Polygon):",
            "    def __init__(self, pts):",
            "        assert len(pts) == 3, \"Not 3 points\"",
            "        super().__init__(pts)",
            "",
            "    @property",
            "    def circle_in(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_B",
            "        # 内接円",
            "        dp1 = self.points[1] - self.points[0]",
            "        dp2 = self.points[2] - self.points[0]",
            "        dd = [(self.points[2] - self.points[1]).abs, dp2.abs, dp1.abs]",
            "        dsum = sum(dd)",
            "        r = abs(dp1.det(dp2)) / dsum",
            "        c = Point(0, 0)",
            "        for ci, ddi in zip(self.points, dd):",
            "            c = c + ci * ddi",
            "        c = c / dsum",
            "        return Circle(c, r)",
            "",
            "    @property",
            "    def circle_circumscribed(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_C",
            "        # 外接円",
            "        dp1 = (self.points[0] - self.points[1]) * 2 # a, b",
            "        dp2 = (self.points[0] - self.points[2]) * 2 # c, d",
            "        p = self.points[0].abs ** 2 - self.points[1].abs ** 2",
            "        q = self.points[0].abs ** 2 - self.points[2].abs ** 2",
            "        det = dp1.det(dp2)",
            "        x = dp2.y * p - dp1.y * q",
            "        y = dp1.x * q - dp2.x * p",
            "        if det < -EPS:",
            "            x *= -1; y *= -1; det *= -1",
            "        x /= det; y /= det",
            "        c = Point(x, y)",
            "        r = c.dist(self.points[0])",
            "        return Circle(c, r)",
            "",
            "######################################################################",
            "def closestPair(points):",
            "    \"\"\"",
            "    最近点対 (分割統治法)",
            "    \"\"\"",
            "    def _closest_Pair(points):",
            "        n=len(points)",
            "        if n <= 1:",
            "            return MAX",
            "        m = n//2",
            "        x = points[m].x",
            "        d = min(_closest_Pair(points[:m]), _closest_Pair(points[m:]))",
            "        points.sort(key=lambda p:p.y)",
            "        L=[]",
            "        for i in range(n):",
            "            if abs(points[i].x - x) < d:",
            "                for j in range(len(L)):",
            "                    if points[i].y-L[-j-1].y >= d:",
            "                        break",
            "                    d = min(d, points[i].dist(L[-j-1]))",
            "                L.append(points[i])",
            "        return d",
            "    points.sort(key=lambda p: p.x)",
            "    return _closest_Pair(points)",
            "",
            "######################################################################",
            "",
            "# x, y = map(int, input().split())",
            "# p = Point(x, y)",
            "# x, y, u, v = map(int, input().split())",
            "# l = Line(Point(x, y), Point(u, v))",
            "# poly = Polygon([Point(*tuple(map(int, input().split()))) for _ in range(m)])",
            "# x, y, r = map(int, input().split())",
            "# cir = Circle(Point(x, y), r)",
            "# tri = Polygon([tuple(map(int, input().split())) for _ in range(3)])",
            "",
            "P = []",
            "for _ in range(int(input())):",
            "    x,y=map(float,input().split())",
            "    P.append(Point(x,y))",
            "print('{:.10f}'.format(closestPair(P)))",
            "",
            "######################################################################",
            "",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ],
        "scope": "python"
    },
    "Lib_AL_図形_座標回転": {
        "prefix": [
            "Lib_AL_図形_座標回転"
        ],
        "body": [
            "",
            "########################",
            "import math",
            "",
            "########################",
            "# 二次元座標を回転",
            "########################",
            "def rotate(point: tuple, R, isradian=True) -> tuple:",
            "    if not isradian:",
            "        R = math.radians(R)  # Rが度数の場合",
            "    a, b = point",
            "    cos, sin = math.cos(R), math.sin(R)",
            "    return (cos*a-sin*b, sin*a+cos*b)",
            "",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ],
        "scope": "python"
    },
    "巡回セールスマン問題": {
        "prefix": [
            "Lib_A_巡回セールスマン問題_TSP_bitDP"
        ],
        "body": [
            "# bitDP",
            "# dp[s][i]  集合sに行って、今iにいる場合の最小距離",
            "",
            "INF = 10**9",
            "n, m = map(int, input().split())",
            "",
            "# 辺の情報",
            "dist = [[INF] * n for _ in range(n)]",
            "for i in range(n):",
            "    dist[i][i] = 0",
            "for _ in range(m):",
            "    fm, to, d = map(int, input().split())",
            "    # fm, to = fm - 1, to - 1",
            "    dist[fm][to] = d",
            "",
            "# 距離関数",
            "def d(fm, to):",
            "    if dist[fm][to] != INF:",
            "        return dist[fm][to]",
            "    else:",
            "        # 何か変則処理",
            "        # ex. dist[fm][to] = abs(a-p) + abs(b-q) + max(0, r-c)",
            "        return dist[fm][to]",
            "",
            "# dp[s][i]  集合sに行って、今iにいる場合の最小距離",
            "# 最初は0だがsにはカウントしない",
            "dp = [[INF] * n for _ in range(1 << n)]",
            "for first in range(n):",
            "    dp[1 << first][first] = d(0, first)",
            "",
            "for s in range(1, 1 << n):",
            "    for fm in range(n):",
            "        if not s >> fm & 1: continue    # fmがsに無い場合->スキップ",
            "        if dp[s][fm] == INF: continue   # 到達距離がINF->スキップ",
            "        for to in range(n):",
            "            if s >> to & 1: continue    # すでにtoがsにいる場合->スキップ",
            "            next_s = s | (1 << to)      # toを追加した状態",
            "            dp[next_s][to] = min(dp[next_s][to], dp[s][fm] + d(fm, to))",
            "",
            "ret = dp[-1][0]",
            "",
            "if ret == INF:",
            "    print(-1)",
            "else:",
            "    print(ret)",
            "",
            ""
        ],
        "description": [
            "巡回セールスマン問題"
        ],
        "scope": "python"
    },
    "高速フーリエ変換(convolution, FFT)": {
        "prefix": [
            "Lib_A_FFT_convolution"
        ],
        "body": [
            "# https://atcoder.jp/contests/practice2/tasks/practice2_f",
            "# https://atcoder.jp/contests/atc001/tasks/fft_c",
            "# Σa_i * x^i * Σb_j * x^j  = Σ(Σa_i*b_j) * x ^t  t = i + jとなる場合の",
            "# Σa_i*b_j の列を求める",
            "",
            "mod = 998244353",
            "",
            "g = 3   #primitive root",
            "ginv = pow(g, mod-2, mod)",
            "",
            "W = [pow(g, (mod-1)>>i, mod) for i in range(24)]",
            "Winv = [pow(ginv, (mod-1)>>i, mod) for i in range(24)]",
            "",
            "def fft(k, f):",
            "    for l in range(1, k+1)[::-1]:",
            "        d = 1 << l - 1",
            "        U = [1]",
            "        for i in range(d):",
            "            U.append(U[-1]*W[l]%mod)",
            "        for i in range(1<<k - l):",
            "            for j in range(d):",
            "                s = i*2*d + j",
            "                f[s], f[s+d] = (f[s] + f[s+d])%mod, U[j]*(f[s] - f[s+d])%mod",
            "",
            "def ifft(k, f):",
            "    for l in range(1,k+1):",
            "        d = 1 << l - 1",
            "        for i in range(1<<k - l):",
            "            u = 1",
            "            for j in range(i*2*d, (i*2+1)*d):",
            "                f[j+d] *= u",
            "                f[j],f[j+d] = (f[j]+f[j+d])%mod, (f[j]-f[j+d])%mod",
            "                u = u * Winv[l] % mod",
            "",
            "def convolve(a, b):",
            "    la, lb = len(a), len(b)",
            "    le = la + lb - 1",
            "    k = le.bit_length()",
            "    n = 1 << k",
            "    ninv = pow(n,mod-2,mod)",
            "    a += [0]*(n-la)",
            "    b += [0]*(n-lb)",
            "    fft(k,a)",
            "    fft(k,b)",
            "    a = [ai * bi % mod for ai, bi in zip(a, b)]",
            "    ifft(k,a)",
            "    return [ai * ninv % mod for ai in a[:le]]",
            "",
            "",
            "n,m = map(int,input().split())",
            "A = list(map(int,input().split()))",
            "B = list(map(int,input().split()))",
            "",
            "print(*convolve(A,B))",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "LCS最長共通部分列": {
        "prefix": [
            "Lib_LCS最長共通部分列#"
        ],
        "body": [
            "#####################################",
            "# LCS(longest common sequence)",
            "# 部分列で最長の共通のもの",
            "#####################################",
            "# https://atcoder.jp/contests/dp/tasks/dp_f",
            "",
            "# dp[i+1][j+1]:= s の i 文字目までと t の j 文字目まででの LCS の長さ",
            "class LCS:",
            "    def __init__(self, S, T) -> None:",
            "        self.Type = type(S)",
            "        if self.Type == str:",
            "            S = list(S)",
            "            T = list(T)",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = n = len(S)",
            "        self.lt = m = len(T)",
            "        self.dp = [[0]*(m+1) for _ in range(n+1)]",
            "        dp = self.dp",
            "        for i, si in enumerate(S):",
            "            for j, tj in enumerate(T):",
            "                if si == tj:",
            "                    dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + 1)",
            "                else:",
            "                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])",
            "",
            "    def __len__(self):",
            "        # LCSの長さ",
            "        return self.dp[self.ls][self.lt]",
            "",
            "    def __str__(self):",
            "        # 復元",
            "        ret = []",
            "        i, j = self.ls, self.lt",
            "        dp = self.dp",
            "        while i and j:",
            "            # (i-1, j) -> (i, j) と更新されていた場合",
            "            if dp[i][j] == dp[i-1][j]:",
            "                i -= 1   # DP の遷移を遡る",
            "            # (i, j-1) -> (i, j) と更新されていた場合",
            "            elif dp[i][j] == dp[i][j-1]:",
            "                j -= 1   # DP の遷移を遡る",
            "            # (i-1, j-1) -> (i, j) と更新されていた場合",
            "            else:",
            "                ret.append(self.S[i-1])",
            "                # このとき s[i-1] == t[j-1] なので、t[j-1] + res でも OK",
            "                i -= 1; j -= 1   # DP の遷移を遡る",
            "        ret = ret[::-1]",
            "        if self.Type == str: ret = ''.join(ret)",
            "        return ''.join(ret)",
            "",
            "",
            "#####################",
            "#s = list(input())",
            "#t = list(input())",
            "s = '948640'",
            "t = '540820'",
            "lcs = LCS(s, t)",
            "print(len(lcs))",
            "print(lcs)",
            ""
        ],
        "description": [
            "Lib_LCS最長共通部分列"
        ],
        "scope": "python"
    },
    "LIS最長増加部分列": {
        "prefix": [
            "Lib_LIS最長増加部分列"
        ],
        "body": [
            "#####################################",
            "# 最長増加部分列 dp[k]",
            "# 今まで見た来たものの中で、単調増加(非減少)な部分列であって、",
            "# 長さ k であるようなもののうち、その最後の要素の最小値",
            "# 新しいアイテムuだったとき",
            "# dp[k] < u となる一番右の列(k)を特定しその次のdp[k+1]を小さければ更新する",
            "# rem: kに対して単調増加",
            "from bisect import bisect, bisect_left",
            "",
            "class LIS:",
            "    \"\"\"",
            "    fg: 0:単調非減少, 1:単調増加",
            "    \"\"\"",
            "    def __init__(self, x:list, fg=1):",
            "        n = len(x)",
            "        res = [0] * n",
            "        dp = []",
            "        for i, xi in enumerate(x):",
            "            if fg == 0: # 非減少",
            "                pos = bisect(dp, xi)",
            "            elif fg == 1: # 単調増加",
            "                pos = bisect_left(dp, xi)",
            "            res[i] = pos + 1",
            "            if len(dp) <= pos:",
            "                dp.append(xi)",
            "            else:",
            "                dp[pos] = xi",
            "        self.length = len(dp)",
            "        restore = []",
            "        nw = self.length",
            "        for i in range(n)[::-1]:",
            "            if nw == res[i]:",
            "                restore.append(x[i])",
            "                nw -= 1",
            "        restore.reverse()",
            "        self.restore = restore",
            "        self.lis = dp",
            "        self.res = res",
            "",
            "",
            "",
            "####################################",
            "",
            "#n = int(input())",
            "#a = list(map(int, input().split()))",
            "n = 5",
            "a = [3, 1, 4, 2, 5, 9, 3]",
            "lis = LIS(a)",
            "print(LIS(a).length)",
            "",
            "# n = 5",
            "# a = [3, 1, 4, 2, 5, 9, 3]",
            "# length = 4",
            "# restore = [1, 2, 5, 9]",
            "# lis = [1, 2, 3, 9]",
            "# res = [1, 1, 2, 2, 3, 4, 3]",
            ""
        ],
        "description": [
            "Lib_LIS最長増加部分列"
        ],
        "scope": "python"
    },
    "Mo'sAlgorithm#": {
        "prefix": [
            "Lib_Mos_モアルゴリズム"
        ],
        "body": [
            "",
            "class _Mo:",
            "    def __init__(self, N:int, Q:int):",
            "        self.N=N",
            "        self.Q = Q",
            "        self.shift = 20",
            "        self.M = int(Q**0.5)+1  # bucket num",
            "        self.data = [0] * Q",
            "        self.query = [[] for _ in range(self.M)]",
            "",
            "    def add_query(self, l:int, r:int, i:int):",
            "        \"\"\"",
            "        半開区間 [l,r)",
            "        \"\"\"",
            "        sft=self.shift",
            "        h=l*self.M//self.N",
            "        self.data[i]=(l<<sft)|r",
            "        self.query[h].append(((r if h&1 else -r)<<sft)+i)",
            "    def solve(self):",
            "        mask=(1<<self.shift)-1",
            "        assert max(self.N, self.Q)<=mask",
            "        L=R=0",
            "        ret = [0]*self.Q",
            "        for bucket in self.query:",
            "            bucket.sort()",
            "            for lri in bucket:",
            "                i = lri&mask",
            "                l,r=divmod(self.data[i],1<<self.shift)",
            "                while L>l:",
            "                    L-=1",
            "                    self.add_left(L)",
            "                while R<r:",
            "                    self.add_right(R)",
            "                    R+=1",
            "                while L<l:",
            "                    self.remove_left(L)",
            "                    L+=1",
            "                while R>r:",
            "                    R-=1",
            "                    self.remove_right(R)",
            "                ret[i] = self.get_state()",
            "        return ret",
            "",
            "N,Q=map(int,input().split())",
            "# N=int(input())",
            "A=list(map(int,input().split()))",
            "",
            "class Mo(_Mo):",
            "    def __init__(self, N, Q):",
            "        super().__init__(N, Q)",
            "        self.value = 0",
            "        self.count = [0] * (max(A)+1)",
            "    def get_state(self):",
            "        return self.value",
            "    # https://atcoder.jp/contests/abc293/tasks/abc293_g",
            "    def add_left(self, i):",
            "        a = A[i]",
            "        x = self.count[a]",
            "        self.count[a] += 1",
            "        self.value += x*(x-1) // 2",
            "    def remove_left(self, i):",
            "        a = A[i]",
            "        x = self.count[a]",
            "        self.count[a] -= 1",
            "        self.value -= (x-1)*(x-2)//2",
            "",
            "    # https://atcoder.jp/contests/abc174/tasks/abc174_f",
            "    # def add_left(self, i):",
            "    #     a = A[i]",
            "    #     if a in self.count:",
            "    #         self.count[a] += 1",
            "    #     else:",
            "    #         self.count[a] = 1",
            "    #     if self.count[a] == 1:",
            "    #         self.value += 1",
            "    # def remove_left(self, i):",
            "    #     a = A[i]",
            "    #     self.count[a] -= 1",
            "    #     if self.count[a] == 0:",
            "    #         self.value -= 1",
            "",
            "# https://atcoder.jp/contests/abc242/tasks/abc242_g",
            "    # def add_left(self, i):",
            "    #     a = A[i]",
            "    #     x = self.count[a]",
            "    #     self.count[a] += 1",
            "    #     self.value += (x+1) // 2 - x // 2",
            "    # def remove_left(self, i):",
            "    #     a = A[i]",
            "    #     x = self.count[a]",
            "    #     self.count[a] -= 1",
            "    #     self.value -= x // 2 - (x-1) // 2",
            "",
            "    add_right = add_left",
            "    remove_right = remove_left",
            "",
            "",
            "mo = Mo(N, Q)",
            "# Q=int(input())",
            "for i in range(Q):",
            "    l,r=map(int,input().split())",
            "    mo.add_query(l-1,r, i)",
            "ans = mo.solve()",
            "",
            "print(\"\\n\".join(map(str,ans)))",
            "",
            ""
        ],
        "description": [
            "Mo'sAlgorithm#"
        ],
        "scope": "python"
    },
    "スパンクエリ": {
        "prefix": [
            "Lib_A_スパンクエリ_left_min_position"
        ],
        "body": [
            "#####################################",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "def left_min_position(A, min_value=0):",
            "    ret = []",
            "    stack = []",
            "    stack.append([min_value, -1])",
            "    for i, ai in enumerate(A):",
            "        while stack[-1][0] >= ai:   #",
            "            stack.pop()",
            "        ret.append(stack[-1][1])",
            "        stack.append([ai, i])",
            "    return ret",
            "",
            "def right_min_position(A, min_value=0):",
            "# 右で自分より小さいものがあるindexを高速で計算",
            "    n = len(A)",
            "    return [n - pi - 1 for pi in reversed(left_min_position(A[::-1]))]",
            "",
            "",
            "n = int(input())",
            "A = list(map(int, input().split()))",
            "l = left_min_position(A)",
            "r = right_min_position(A)",
            "",
            "mx = 0",
            "for li, ri, ai in zip(l, r, A):",
            "    mx = max(mx, ai*(ri-li-1))",
            "print(mx)",
            ""
        ],
        "description": [
            "スパンクエリ"
        ],
        "scope": "python"
    },
    "ダブリング": {
        "prefix": [
            "Lib_A_ダブリング_doubbling"
        ],
        "body": [
            "",
            "# https://atcoder.jp/contests/abc167/tasks/abc167_d",
            "",
            "maxdeg = 100",
            "n, k = map(int, input().split())",
            "A = list(map(lambda x: int(x)-1, input().split()))",
            "",
            "def f(i):",
            "    # 1回の遷移",
            "    return A[i]",
            "",
            "def doubbling():",
            "    dp = [[0] * n for _ in range(maxdeg)]",
            "    for i in range(n):",
            "        dp[0][i] = f(i)",
            "",
            "    for t in range(1, maxdeg):",
            "        for i in range(n):",
            "            dp[t][i] = dp[t-1][dp[t-1][i]]",
            "    return dp",
            "",
            "dp = doubbling()",
            "",
            "def fk(i, k):",
            "    # iからk回遷移した時の結果",
            "    for d in range(maxdeg):",
            "        if k >> d & 1: i = dp[d][i]",
            "    return i",
            "",
            "print(fk(0, k)+1)",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "iscription#": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "ランレングス圧縮": {
        "prefix": [
            "Lib_A_ランレングス圧縮_rle"
        ],
        "body": [
            "#####################################",
            "from itertools import groupby",
            "strings = \"aabbbbbbbbbbbba\"",
            "strings = [1,3,4,1,1,1,5,5,7]",
            "",
            "rle = [(k, len(list(g))) for k,g in groupby(strings)]",
            "split = [list(g) for k, g in groupby(strings)]",
            "print(rle)",
            "print(split)",
            "#[('a', 2), ('b', 12), ('a', 1)]"
        ],
        "description": [
            "ランレングス圧縮"
        ],
        "scope": "python"
    },
    "ループ#": {
        "prefix": [
            "Lib_A_Loop_ループ"
        ],
        "body": [
            "class Loop():",
            "    \"\"\"ループを検索して計算量圧縮",
            "",
            "        Parameters",
            "        ----------",
            "        n : int",
            "            鳩の巣の数",
            "        x : int",
            "            初期値",
            "        f : function",
            "            次の値を決める関数",
            "",
            "        Notes",
            "        ----------",
            "        0->1->...->s_t-1 -> st->...-> s_t+x─┐",
            "                             └─────────┘",
            "        https://atcoder.jp/contests/typical90/tasks/typical90_bf",
            "",
            "    \"\"\"",
            "    def __init__(self, n, x, f, g):",
            "        self.hole = n",
            "        self.ini_p = x",
            "        self.nextp = f",
            "        self.value = g",
            "        self.__build()",
            "",
            "",
            "    def __build(self):",
            "        x = self.ini_p",
            "        seen = defaultdict(int)",
            "        seqs = []",
            "        for i in range(self.hole + 10):",
            "            seen[x] = i",
            "            seqs.append(x)",
            "            x = self.nextp(x)",
            "            if x in seen: break",
            "        p = seen[x]",
            "        self.ini_seq = self.sequence([self.value(pos) for pos in seqs[:p]])",
            "        self.lp_seq = self.sequence([self.value(pos) for pos in seqs[p:]])",
            "",
            "",
            "    def get_kth(self, k:int)->int:",
            "        \"\"\"k番目の値を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.seq[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            _, k = divmod(k, self.lp_seq.len)",
            "            return self.lp_seq.seq[k]",
            "",
            "",
            "    def sum_kth(self, k:int)->int:",
            "        \"\"\"k番目までの値の累積和を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.acc[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            t, k = divmod(k, self.lp_seq.len)",
            "            ret = self.ini_seq.acclast",
            "            ret += self.lp_seq.acclast * t",
            "            ret += self.lp_seq.acc[k]",
            "            return ret",
            "",
            "",
            "    class sequence:",
            "        def __init__(self, seq):",
            "            self.seq = seq          # 配列",
            "            self.len = len(seq)     # 配列の個数",
            "            self.acc = list(accumulate(seq))    # 配列の累積和",
            "            if self.len == 0:",
            "                self.acclast = 0    # 配列の累積和",
            "            else:",
            "                self.acclast = self.acc[-1]    # 配列の累積和",
            "",
            "",
            "n, k = map(int, input().split())",
            "",
            "if n == 0:",
            "    print(0)",
            "    exit()",
            "",
            "def f(x):",
            "    ...",
            "",
            "def g(x):",
            "    ...",
            "",
            "",
            "lp = Loop(n, 0, f, g)",
            "print(lp.get_kth(k))",
            ""
        ],
        "description": [
            "ループ#"
        ],
        "scope": "python"
    },
    "三分探索": {
        "prefix": [
            "Lib_A_三分探索"
        ],
        "body": [
            "#######################",
            "# ムーアの法則",
            "# 三分探索/黄金分割探索",
            "#######################",
            "",
            "def f(x): return x**2",
            "",
            "d = 0.000000001",
            "low, high = 0, 1000",
            "",
            "# 分割割合",
            "alp = 1/3           #三分探索",
            "alp = (3-5**0.5)/2  #黄金分割探索",
            "",
            "while abs(f(low) - f(high)) > d:",
            "    l_ = high * alp + (1-alp) * low",
            "    h_ = high * (1-alp) + alp * low",
            "    if f(h_) < f(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "print(f'{f(low):.10f}')",
            "",
            "",
            "",
            "",
            "#######################",
            "# 内包円",
            "# 三分探索",
            "# https://atcoder.jp/contests/abc151/tasks/abc151_f",
            "# 平面上の N 個の点 (xi, yi) が与えられます。",
            "# これら全てを内部または周上に含む円の半径の最小値を求めてください。",
            "#######################",
            "",
            "n = int(input())",
            "pt = [tuple(map(int, input().split())) for i in range(n)]",
            "",
            "def f(x, y):",
            "    # (x, y)を与えたときに、各点との距離の最大値",
            "    return max([((x-u)**2 + (y-v)**2)**0.5 for u, v in pt])",
            "",
            "d = 0.0000001",
            "",
            "def g(x):",
            "    low, high = 0, 1000",
            "    for i in range(80):",
            "        l_ = (high+2*low)/3",
            "        h_ = (high*2+low)/3",
            "        if f(x, h_)<f(x, l_):",
            "            low = l_",
            "        else:",
            "            high = h_",
            "    return f(x, low)",
            "",
            "",
            "low, high = 0, 1000",
            "for i in range(80):",
            "    l_ = (high+2*low)/3",
            "    h_ = (high*2+low)/3",
            "    if g(h_)<g(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "",
            "print(g(low))",
            "",
            ""
        ],
        "description": [
            "三分探索"
        ],
        "scope": "python"
    },
    "三分探索int": {
        "prefix": [
            "Lib_A_三分探索整数"
        ],
        "body": [
            "",
            "def f(x): return x**2",
            "",
            "low, high = 0, 1000",
            "while high - low > 2:",
            "    l_ = low + (high - low) // 3",
            "    h_ = high - (high - low) // 3",
            "    if f(h_) < f(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "ret = min(f(low), f(high))",
            "print(ret)",
            "",
            ""
        ],
        "description": [
            "三分探索int"
        ],
        "scope": "python"
    },
    "二次元点クエリ": {
        "prefix": [
            "compress_zaatsu",
            "Lib_A_二次元点クエリ"
        ],
        "body": [
            "from bisect import bisect_left, bisect_right",
            "",
            "class RangeSearchQuery:",
            "    \"\"\"",
            "    二次元点のリストで範囲を指定して、含まれる要素番号を出力する",
            "    ２次元の平面上の点の集合に対し、与えられた領域に含まれる点を列挙してください。",
            "    ただし、与えられた点の集合に対して、点の追加・削除は行われません。",
            "    \"\"\"",
            "    def __init__(self, points):",
            "        self.n = len(points)",
            "        self.p_id = {v: i for i, v in enumerate(points)}  #座圧",
            "        data = dict()",
            "        for x, y in points:",
            "            if x not in data: data[x] = []",
            "            data[x].append(y)",
            "        self.d_x = sorted(list(data.keys()))",
            "        for dv in data.values(): dv.sort()",
            "        self.data = data",
            "",
            "    def query(self, sx, tx, sy, ty):",
            "        ans = []",
            "        left = bisect_left(self.d_x, sx)",
            "        right = bisect_right(self.d_x, tx)",
            "        for kx in self.d_x[left:right]:",
            "            y_left = bisect_left(self.data[kx], sy)",
            "            y_right = bisect_right(self.data[kx], ty)",
            "            for ky in self.data[kx][y_left: y_right]:",
            "                ans.append(self.p_id[(kx, ky)])",
            "        return ans",
            "",
            "n = int(input())",
            "A = [tuple(map(int, input().split())) for _ in range(n)]",
            "RSQ = RangeSearchQuery(A)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    que = tuple(map(int, input().split()))",
            "    ans = RSQ.query(*que)",
            "    for ans_i in sorted(ans):",
            "        print(ans_i)",
            "    print()",
            "",
            ""
        ],
        "description": [
            "二次元点クエリ"
        ],
        "scope": "python"
    },
    "区間和の最大値": {
        "prefix": [
            "Lib_A_区間和の最大値"
        ],
        "body": [
            "",
            "class Imos:",
            "    def __init__(self, a:list):",
            "        self.origin = a",
            "        self.accum = [0]",
            "        for ai in a:",
            "            self.accum.append(self.accum[-1] + ai)",
            "        self.n = self.accum",
            "        self.INF = float('inf')",
            "",
            "    def _get_max(self, accum:list):",
            "        \"\"\"",
            "        区間和(ar-al)の最大値",
            "        max(ar-min(al))",
            "        \"\"\"",
            "        ret_min = - self.INF",
            "        min_al = self.INF",
            "        for ar in accum:",
            "            ret_min= max(ar - min_al, ret_min)",
            "            min_al = min(ar, min_al)",
            "        return ret_min",
            "",
            "    @property",
            "    def get_max(self):",
            "        return self._get_max(self.accum)",
            "",
            "    @property",
            "    def get_min(self):",
            "        return - self._get_max([-ai for ai in self.accum])",
            "",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "for i, ai in enumerate(a):",
            "    if ai==0:",
            "        a[i] = -1",
            "",
            "im = Imos(a)",
            "print(im.get_max - im.get_min + 1)",
            "",
            ""
        ],
        "description": [
            "区間和を累積和の差分としてその最大値を求めるar-al"
        ],
        "scope": "python"
    },
    "半分全列挙": {
        "prefix": [
            "Lib_A_半分全列挙"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc184/tasks/abc184_f",
            "# 半分全列挙",
            "# n <= 40 だと半分で全列挙したものをそれぞれ計算してマージ処理する",
            "",
            "n, t = map(int, input().split())",
            "vs = list(map(int, input().split()))",
            "",
            "def get_list(vl):",
            "    ret = [0]",
            "    svl = sorted(vl)",
            "    for vi in svl:",
            "        for j in range(len(ret)):",
            "            x = vi + ret[j]",
            "            if x > t: continue",
            "            ret.append(x)",
            "    return sorted(ret)",
            "",
            "lower = get_list(vs[:n//2])",
            "upper = get_list(vs[n//2:])",
            "",
            "ret = 0",
            "up = len(upper) - 1",
            "for f in lower:",
            "    while up >= 0 and (upper[up]+f) > t:",
            "        up -= 1",
            "    ret = max(ret, upper[up]+f)",
            "",
            "print(ret)",
            ""
        ],
        "description": [
            "半分全列挙"
        ],
        "scope": "python"
    },
    "差分最小値探索": {
        "prefix": [
            "Lib_A_差分最小値探索"
        ],
        "body": [
            "def near(a:list, b:list) -> tuple:",
            "    \"\"\"二つのソートされたリストの要素の差の最小値を探索",
            "",
            "    Returns",
            "    -------",
            "    tuple",
            "        最小となる位置の組み合わせと値",
            "        (i, j, a[i]-b[j])",
            "    \"\"\"",
            "    INF = float('inf')",
            "    if len(a) == 0 or len(b) == 0:",
            "        return (None, None, INF)",
            "    i, j = 0, 0",
            "    retd = INF",
            "    reta = -1",
            "    retb = -1",
            "    while i < len(a) and j < len(b):",
            "        dist = abs(a[i] - b[j])",
            "        if retd > dist:",
            "            retd = dist",
            "            reta= i",
            "            retb = j",
            "        if a[i] > b[j]:",
            "            j += 1",
            "        elif a[i] < b[j]:",
            "            i += 1",
            "        else:",
            "            break",
            "    return (reta, retb, retd)"
        ],
        "description": [
            "差分最小値探索"
        ],
        "scope": "python"
    },
    "座標圧縮": {
        "prefix": [
            "Lib_A_座標圧縮_compress_zaatsu"
        ],
        "body": [
            "",
            "from bisect import bisect_left",
            "class Compress:",
            "    \"\"\"一次元座標圧縮",
            "",
            "    Parameters",
            "    ----------",
            "    points : list",
            "    値のリスト [100,300,50,900,200]",
            "",
            "    Returns",
            "    -------",
            "    pos : {50: 0, 100: 1, 200: 2, 300: 3, 900: 4}",
            "    vals : {0: 50, 1: 100, 2: 200, 3: 300, 4: 900}",
            "    list : [1, 3, 0, 4, 2]",
            "    \"\"\"",
            "    INF = 10**10",
            "    def __init__(self, points, spacing=False, reverse=False):",
            "        pos, vals, sx = {}, {}, set(points)",
            "        if spacing: #スペースを作る場合",
            "            for p in points: sx.add(p+1)",
            "            sx.add(-self.INF)",
            "            sx.add(self.INF)",
            "",
            "        for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "            pos[xi], vals[i] = i, xi",
            "        self.pos, self.vals = pos, vals",
            "        self.original_list, self.list = points, [pos[xi] for xi in points]",
            "        self.valuesequence = sorted(self.pos.keys())",
            "",
            "    def __contains__(self, original_value):",
            "        return original_value in self.pos.keys()",
            "",
            "    def index(self, original_value):",
            "        \"\"\"",
            "        元の値 -> 圧縮後のインデックス/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        if original_value in self:",
            "            return bisect_left(self.valuesequence, original_value)",
            "        return None",
            "",
            "    def value(self, index):",
            "        \"\"\"",
            "        圧縮後のインデックス -> 元の値/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        if index in self.vals:",
            "            return self.vals(index)",
            "        return None",
            "",
            "# c = Compress([100,300,50,900,200], spacing=True)",
            ""
        ],
        "description": [
            "座標圧縮"
        ],
        "scope": "python"
    },
    "座標圧縮二次元": {
        "prefix": [
            "Lib_A_座標圧縮2D_compress_zaatsu"
        ],
        "body": [
            "from bisect import bisect_left",
            "class Compress:",
            "    INF = 10**10",
            "    def __init__(self, points, spacing=False, reverse=False):",
            "        pos, vals, sx = {}, {}, set(points)",
            "        if spacing: #スペースを作る場合",
            "            for p in points: sx.add(p+1)",
            "            sx.add(-self.INF)",
            "            sx.add(self.INF)",
            "",
            "        for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "            pos[xi], vals[i] = i, xi",
            "        self.pos, self.vals = pos, vals",
            "        self.original_list, self.list = points, [pos[xi] for xi in points]",
            "        self.valuesequence = sorted(self.pos.keys())",
            "",
            "    def __contains__(self, original_value):",
            "        return original_value in self.pos.keys()",
            "",
            "    def index(self, original_value):",
            "        \"\"\"",
            "        元の値 -> 圧縮後のインデックス/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        if original_value in self:",
            "            return bisect_left(self.valuesequence, original_value)",
            "        return None",
            "",
            "    def value(self, index):",
            "        \"\"\"",
            "        圧縮後のインデックス -> 元の値/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        if index in self.vals:",
            "            return self.vals(index)",
            "        return None",
            "",
            "",
            "class Compress2d:",
            "    \"\"\"二次元座標圧縮",
            "    \"\"\"",
            "    def __init__(self, points, spacing=False):",
            "        sx = [point[0] for point in points]",
            "        sy = [point[1] for point in points]",
            "        self.xc = Compress(sx, spacing=spacing)",
            "        self.yc = Compress(sy, spacing=spacing)",
            "        self.original_list = points",
            "        self.list = list(zip(self.xc.list, self.yc.list))",
            "        self.n = len(self.xc.valuesequence)",
            "        self.m = len(self.yc.valuesequence)",
            "        if len(points[0]) == 3:",
            "            self.pointvalues = {self.index((x, y)): v for x, y, v in points}",
            "        else:",
            "            self.pointvalues = {self.index((x, y)): 0 for x, y in points}",
            "",
            "    def index(self, original_point):",
            "        \"\"\"",
            "        元の値 -> 圧縮後のインデックス/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        x, y = original_point",
            "        return self.xc.index(x), self.yc.index(y)",
            "",
            "    def value(self, index_x, index_y):",
            "        \"\"\"",
            "        圧縮後のインデックス -> 元の値/",
            "        元の値がない場合は、None",
            "        \"\"\"",
            "        return tuple(self.xc.value(index_x), self.yc.value(index_y))",
            "",
            "    def xvalue(self, index):",
            "        return self.xc.value(index)",
            "",
            "    def yvalue(self, index):",
            "        return self.yc.value(index)",
            "",
            "# c = Compress2d([(1,1),(2,4),(5,3)], spacing=True)",
            "# print(c.xc.valuesequence)",
            "# print(c.yc.valuesequence)",
            "# print(c.list)"
        ],
        "description": [
            "座標圧縮二次元"
        ],
        "scope": "python"
    },
    "数直線上の距離の合計": {
        "prefix": [
            "Lib_A_数直線上の距離の合計"
        ],
        "body": [
            "",
            "from bisect import bisect",
            "",
            "class points_diffs:",
            "    def __init__(self, A:list):",
            "        self.X = sorted(A)",
            "        self.RX = [0]",
            "        self.N = len(A)",
            "        for ai in self.X:",
            "            self.RX.append(self.RX[-1] + ai)",
            "",
            "    def cost_left(self, x):",
            "        \"\"\"",
            "        xの左側の点をxに持ってくるコスト",
            "        \"\"\"",
            "        u = bisect(self.X, x)",
            "        return u*x - self.RX[u]",
            "",
            "    def cost_right(self, x):",
            "        \"\"\"",
            "        xの右側の点をxに持ってくるコスト",
            "        \"\"\"",
            "        u = bisect(self.X, x)",
            "        return self.RX[-1] - self.RX[u] - (self.N-u) * x",
            "",
            "    def cost(self, x):",
            "        return self.cost_left(x) + self.cost_right(x)",
            "",
            "    def minvalue(self, f):",
            "        \"\"\"xコストに関する最小値\"\"\"",
            "        \"\"\"\"\"\"",
            "        l = min(self.A)",
            "        r = max(self.A)",
            "        while r - l > 2:",
            "            _l = l + (r-l)//3",
            "            _r = r - (r-l)//3",
            "            if f(_l) > (_r):",
            "                l = _l",
            "            else:",
            "                r = _r",
            "        return min(f(l), f(r))",
            "",
            "A = [0, 1, 2, 3, 3, 5]",
            "pd = points_diffs(A)",
            "d = 1",
            "print(pd.minvalue(lambda x: pd.cost_left(x) + pd.cost_right(x+d)))",
            ""
        ],
        "description": [
            "数直線上の点を一か所に集める時のコスト"
        ],
        "scope": "python"
    },
    "転倒数": {
        "prefix": [
            "Lib_A_転倒数"
        ],
        "body": [
            "# 転倒数",
            "# 配列中 i<j, ai>ajとなるものの個数",
            "# https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_j",
            "class BIT:",
            "    def __init__(self, size):",
            "        self.size = size; self.dat = [0]*(size+1)",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size: self.dat[i] += x; i += i & -i",
            "",
            "    def sum(self, r):",
            "        r += 1; s = 0",
            "        while r: s += self.dat[r];r -= r & -r",
            "        return s",
            "",
            "def _compress(points:list) -> list:",
            "    sx = set(points)",
            "    pos = {xi:i for i, xi in enumerate(sorted(set(sx)))}",
            "    return [pos[xi] for xi in points]",
            "",
            "def inv_numbers(a: list, compress=False) -> int:",
            "    _a = _compress(a) if compress else a",
            "    bit = BIT(max(_a) + 2)",
            "    ret = 0",
            "    for i, ai in enumerate(_a):",
            "        ret += i - bit.sum(ai); bit.add(ai, 1)",
            "    return ret",
            "",
            "###################################",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "ret = inv_numbers(a)",
            "print(ret)"
        ],
        "description": [
            "Lib_転倒数"
        ],
        "scope": "python"
    },
    "部分列の個数": {
        "prefix": [
            "Lib_部分列個数_subsetcount#"
        ],
        "body": [
            "",
            "def count_subsets(S, mod=10**9+7):",
            "    \"\"\"",
            "    部分列（連続でない）の個数を数える",
            "    空集合を含める",
            "    \"\"\"",
            "    if type(S) == str:",
            "        S = [ord(si)-ord('a') for si in S]",
            "    ls = len(S)",
            "    maxs = max(S)",
            "    pps = [[-1] * (maxs+1) for _ in range(ls+1)]",
            "    for i, si in enumerate(S):",
            "        for j in range(maxs+1):",
            "            pps[i+1][j] = pps[i][j]",
            "            if si == j: pps[i+1][j] = i",
            "",
            "    dp = [0] * (ls+1)",
            "    dp[0] = 1",
            "    for i, si in enumerate(S):",
            "        dp[i+1] = dp[i]",
            "        if pps[i][si] == -1:",
            "            dp[i+1] += dp[i]",
            "        else:",
            "            dp[i+1] += dp[i] - dp[pps[i][si]]",
            "        dp[i+1] %= mod",
            "",
            "    return dp[ls]",
            "",
            "",
            "#####################",
            "",
            "",
            "# https://atcoder.jp/contests/past202206-open/tasks/past202206_k",
            "class CountSubsets:",
            "    def __init__(self, S, T, mod) -> None:",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = n = len(S)",
            "        self.lt = m = len(T)",
            "        self.dp = [[0]*(m+1) for _ in range(n+1)]",
            "        self._adj()",
            "        self.mod = mod",
            "        self.scS, self.ppS = self._substr_count(self.S)",
            "        self.scT, self.ppT = self._substr_count(self.T)",
            "        self.scbothST = self._substr_count_both()",
            "",
            "    def _adj(self):",
            "        mn = min(min(self.S), min(self.T))",
            "        self.S = [u - mn for u in self.S]",
            "        self.T = [u - mn for u in self.T]",
            "        self.Max = max(max(self.S), max(self.T))",
            "",
            "    def _pp(self, S):",
            "        ls = len(S)",
            "        pps = [[-1] * (self.Max+1) for _ in range(ls+1)]",
            "        for i, si in enumerate(S):",
            "            for j in range(self.Max+1):",
            "                pps[i+1][j] = pps[i][j]",
            "                if si == j: pps[i+1][j] = i",
            "        return pps",
            "",
            "    def _substr_count(self, S):",
            "        mod = self.mod",
            "        pps = self._pp(S)",
            "        ls = len(S)",
            "        dp = [0] * (ls+1)",
            "        dp[0] = 1",
            "        for i, si in enumerate(S):",
            "            dp[i+1] = dp[i]",
            "            if pps[i][si] == -1:",
            "                dp[i+1] += dp[i]",
            "            else:",
            "                dp[i+1] += dp[i] - dp[pps[i][si]]",
            "            dp[i+1] %= mod",
            "",
            "        return dp[ls], pps",
            "",
            "    def _substr_count_both(self):",
            "        S, T = self.S, self.T",
            "        ls, lt = self.ls, self.lt",
            "        pps, ppt = self.ppS, self.ppT",
            "        dp = [[0] * (lt+1) for _ in range(ls+1)]",
            "        for i in range(ls+1):",
            "            dp[i][0] = 1",
            "        for j in range(lt+1):",
            "            dp[0][j] = 1",
            "",
            "        for i, si in enumerate(S):",
            "            for j, tj in enumerate(T):",
            "                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j]",
            "                if si != tj: continue",
            "                pi, pj = pps[i][si], ppt[j][tj]",
            "                if pi != -1 and pj != -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[i][pj] - dp[pi][j] + dp[pi][pj]",
            "                elif pi != -1 and pj == -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[pi][j]",
            "                elif pi == -1 and pj != -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[i][pj]",
            "                else:",
            "                    dp[i+1][j+1] += dp[i][j]",
            "                dp[i+1][j+1] %= self.mod",
            "        return dp[ls][lt]",
            "",
            "#####################",
            "",
            "mod = 998244353",
            "s = input()",
            "t = input()",
            "s = [ord(si)-ord('a') for si in s]",
            "t = [ord(si)-ord('a') for si in t]",
            "cs = CountSubsets(s, t, mod)",
            "print((cs.scS+cs.scT-cs.scbothST - 1)%mod)",
            ""
        ],
        "description": [
            "Lib_Substrings_count"
        ],
        "scope": "python"
    },
    "長方形探索": {
        "prefix": [
            "Lib_A_長方形探索_最大正方形_最大長方形"
        ],
        "body": [
            "#####################################",
            "# 最大正方形",
            "def max_square(h, w, G, block):",
            "    dp = [[0] * w for _ in range(h)]",
            "    mx = 0",
            "    for i in range(h):",
            "        if G[i][0] != block: dp[i][0] = 1; mx = 1",
            "    for j in range(w):",
            "        if G[0][j] != block: dp[0][j] = 1; mx = 1",
            "    for i in range(1, h):",
            "        for j in range(1, w):",
            "            if G[i][j] == block: continue",
            "            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1",
            "            mx = max(mx, dp[i][j])",
            "    return mx",
            "",
            "h, w = map(int, input().split())",
            "G = [list(map(int, input().split())) for _ in range(h)]",
            "print(max_square(h, w, G, 1)**2)",
            "",
            "",
            "#####################################",
            "# 最大長方形面積",
            "from collections import deque",
            "def max_rect(h, w, G, block):",
            "    height = [[0] * (w+1) for _ in range(h)]",
            "    for i in range(h):",
            "        for j in range(w):",
            "            if G[i][j] == block: continue",
            "            if i >= 1:",
            "                height[i][j] = height[i-1][j] + 1",
            "            else:",
            "                height[i][j] = 1",
            "",
            "    mx = 0",
            "    for i, hist in enumerate(height):",
            "        stack = deque([])",
            "        for j, h in enumerate(hist):",
            "            if not stack:",
            "                stack.append((j, h))",
            "            else:",
            "                if stack[-1][1] < h:",
            "                    stack.append((j, h))",
            "                elif stack[-1][1] > h:",
            "                    while stack and stack[-1][1] > h:",
            "                        prev =stack.pop()",
            "                        w2 = j - prev[0]",
            "                        h2 = prev[1]",
            "                        mx = max(mx, h2*w2)",
            "                    stack.append((prev[0], h))",
            "    return mx",
            "",
            "h, w = map(int, input().split())",
            "G = [list(map(int, input().split())) for _ in range(h)]",
            "print(max_rect(h, w, G, 1))",
            "",
            "#####################################",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "def left_min_position(A, min_value=0):",
            "    ret = []",
            "    stack = []",
            "    stack.append([min_value, -1])",
            "    for i, ai in enumerate(A):",
            "        while stack[-1][0] >= ai:   #",
            "            stack.pop()",
            "        ret.append(stack[-1][1])",
            "        stack.append([ai, i])",
            "    return ret",
            "",
            "def right_min_position(A, min_value=0):",
            "# 右で自分より小さいものがあるindexを高速で計算",
            "    n = len(A)",
            "    return [n - pi - 1 for pi in reversed(left_min_position(A[::-1], min_value))]",
            "",
            "",
            "n = int(input())",
            "A = list(map(int, input().split()))",
            "l = left_min_position(A)",
            "r = right_min_position(A)",
            "",
            "mx = 0",
            "for li, ri, ai in zip(l, r, A):",
            "    mx = max(mx, ai*(ri-li-1))",
            "print(mx)",
            ""
        ],
        "description": [
            "長方形探索"
        ],
        "scope": "python"
    },
    "削除機能付きHeapque": {
        "prefix": [
            "Lib_D_heapque_min"
        ],
        "body": [
            "",
            "from heapq import heapify, heappush, heappop",
            "class Heapq:",
            "    def __init__(self, a=None):",
            "        self.q = a if a else []",
            "        self.p = []",
            "        heapify(self.q)",
            "",
            "    def heappush(self, x):",
            "        heappush(self.q, x)",
            "    def discard(self, x):",
            "        heappush(self.p, x)",
            "    def _clean(self):",
            "        while self.p and self.q[0]==self.p[0]:",
            "            heappop(self.q)",
            "            heappop(self.p)",
            "    def pop(self, exc=None):",
            "        self._clean()",
            "        if self.q:",
            "            return heappop(self.q)",
            "        return exc",
            "    def heapmin(self, exc=None):",
            "        self._clean()",
            "        if self.q:",
            "            return self.q[0]",
            "        return exc"
        ],
        "description": [
            "削除機能付きHeapque"
        ],
        "scope": "python"
    },
    "削除機能付きMaxMinheapque": {
        "prefix": [
            "Lib_D_heapque_minmax"
        ],
        "body": [
            "from heapq import heappush, heappop",
            "from collections import defaultdict",
            "class DeletableMaxMinHeapq():",
            "    def __init__(self):",
            "        self.Hma = []",
            "        self.Hmi = []",
            "        self.HC = defaultdict(int)",
            "    def heappush(self, x):",
            "        heappush(self.Hma, -x)",
            "        heappush(self.Hmi, x)",
            "        self.HC[x] += 1",
            "    def heappopmax(self):",
            "        t = -heappop(self.Hma)",
            "        while not self.HC[t]:",
            "            t = -heappop(self.Hma)",
            "        self.HC[t] -= 1",
            "        return t",
            "    def heappopmin(self):",
            "        t = heappop(self.Hmi)",
            "        while not self.HC[t]:",
            "            t = heappop(self.Hmi)",
            "        self.HC[t] -= 1",
            "        return t",
            "    def heapmax(self):",
            "        t = -self.Hma[0]",
            "        while not self.HC[t]:",
            "            heappop(self.Hma)",
            "            t = -self.Hma[0]",
            "        return t",
            "    def heapmin(self):",
            "        t = self.Hmi[0]",
            "        while not self.HC[t]:",
            "            heappop(self.Hmi)",
            "            t = self.Hmi[0]",
            "        return t",
            "    def dicard(self, x):",
            "        assert self.HC[x] > 0",
            "        self.HC[x] -= 1",
            "    def __contains__(self, x):",
            "        return 1 if x in self.HC and self.HC[x] else 0",
            "",
            "hq = DeletableMaxMinHeapq()",
            "n, q = map(int, input().split())",
            "a = list(map(int, input().split()))",
            "for ai in a:",
            "    hq.heappush(ai)",
            "",
            "for _ in range(q):",
            "    query = list(map(int, input().split()))",
            "    if query[0] == 0:",
            "        hq.heappush(query[1])",
            "    elif query[0] == 1:",
            "        x = hq.heappopmin()",
            "        print(x)",
            "    else:",
            "        x = hq.heappopmax()",
            "        print(x)",
            "",
            "",
            "# https://judge.yosupo.jp/problem/double_ended_priority_queue",
            "",
            "############",
            ""
        ],
        "description": [
            "削除機能付きMaxMinheapque"
        ],
        "scope": "python"
    },
    "追加削除機能付きMex": {
        "prefix": [
            "Lib_D_Mex"
        ],
        "body": [
            "",
            "from heapq import heappop, heappush",
            "class Mex:",
            "    def __init__(self, arr=[], MAX=10**6) -> None:",
            "        self.MAX = MAX + 5",
            "        self.hist = [0] * (self.MAX+1)",
            "        for a in arr:",
            "            if a > self.MAX: continue",
            "            self.hist[a] += 1",
            "        self.q = []",
            "        self.d = []",
            "        for i in range(self.MAX+1):",
            "            if self.hist[i] == 0:",
            "                heappush(self.q, i)",
            "    def get(self):",
            "        while self.q and self.d and self.q[0]==self.d[0]:",
            "            heappop(self.q)",
            "            heappop(self.d)",
            "        return self.q[0] if self.q else None",
            "    def add(self, x):",
            "        if x > self.MAX: return",
            "        self.hist[x] += 1",
            "        if self.hist[x] == 1:",
            "            heappush(self.d, x)",
            "    def remove(self, x):",
            "        if x > self.MAX: return",
            "        self.hist[x] -= 1",
            "        if self.hist[x] == 0:",
            "            heappush(self.q, x)",
            "",
            "import sys",
            "input = sys.stdin.readline",
            "N,Q = map(int,input().split())",
            "A = list(map(int,input().split()))",
            "qs = [tuple(map(int,input().split())) for _ in range(Q)]",
            "",
            "mex = Mex(A, N)",
            "for i,x in qs:",
            "    i -= 1",
            "    mex.remove(A[i])",
            "    mex.add(x)",
            "    A[i] = x",
            "    print(mex.get())",
            ""
        ],
        "description": [
            "追加削除機能付きMex"
        ],
        "scope": "python"
    },
    "Sorted Multi Set": {
        "prefix": [
            "Lib_D_sorted_multi_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        \"sm[-1]も可能\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        \"xの一番左のインデックス\"",
            "        \"xがない場合は、挿入する位置\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        \"xの一番右のインデックス\"",
            "        \"xがない場合は、挿入する位置\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "###############################################",
            "",
            "sm = SortedMultiset()",
            "",
            "q = int(input())",
            "",
            "for _ in range(q):",
            "    query = tuple(map(int, input().split()))",
            "",
            "    if query[0] == 2:",
            "        x, k = query[1:]",
            "        id = sm.index_right(x) - k",
            "        if id < 0:",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    elif query[0] == 3:",
            "        x, k = query[1:]",
            "        id = sm.index(x) + k - 1",
            "        if id >= len(sm):",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    else:",
            "        sm.add(query[1])",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "Sorted Set": {
        "prefix": [
            "Lib_D_sorted_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        \"sm[-1]も可能\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def _index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def _index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "####################################",
            "    def remove(self, x):",
            "        if x in self:",
            "            self.discard(x)",
            "",
            "    def index(self, x):",
            "        if x in self:",
            "            return self._index(x)",
            "        else:",
            "            return None",
            "",
            "    def strictly_left(self, x):",
            "        return self.lt(x)",
            "",
            "    def strictly_left_pos(self, x):",
            "        v = self.lt(x)",
            "        if v: return self.index(v)",
            "        return None",
            "",
            "    def strictly_right(self, x):",
            "        return self.gt(x)",
            "",
            "    def strictly_right_pos(self, x):",
            "        v = self.gt(x)",
            "        if v: return self.index(v)",
            "        return None",
            "",
            "########################################",
            "",
            "#n, k = map(int, input().split())",
            "#p = list(map(int, input().split()))",
            "",
            "ss = SortedSet()",
            "",
            "#for i in range(n):",
            "#    ss.add(p[i])",
            "#    if len(ss) < k: continue",
            "#    print(ss[-k])",
            "",
            "ss.add(2)",
            "ss.add(3)",
            "ss.add(5)",
            "print(ss.strictly_right_pos(3))",
            "print(2 in ss)",
            "ss.remove(2)",
            "print(2 in ss)"
        ],
        "description": [],
        "scope": "python"
    },
    "Wavelet Matrix": {
        "prefix": [
            "Lib_D_WaveletMatrix"
        ],
        "body": [
            "",
            "class WaveletMatrix:",
            "    \"\"\"",
            "    https://judge.yosupo.jp/problem/range_kth_smallest",
            "    https://scrapbox.io/koki/Wavelet_Matrix",
            "    長さnの数列 a",
            "    access(k): k番目の要素の値",
            "    select(v, k): k番目のvのインデックス",
            "    rank(l, r, v): 区間 [l,r) に含まれる v の個数",
            "    freq(l, r, s, t): 区間 [l,r) に含まれる要素のうち,値が[s, t) である要素の個数",
            "    quantile(l, r, k):区間[l,r)に含まれる要素のうち,値がk番目(0-ind>k+1番目)の値",
            "    kth_smallest(l, r, k): 区間[l,r) に含まれる要素のうち k 番目(0-indexed) に小さいものを返す.",
            "    kth_largest(l, r, k): 区間 [l,r) に含まれる要素のうち k 番目 (0-indexed) に大きいものを返す.",
            "    prev_value(l, r, value): 区間[l, r) に含まれる要素のうち valueより小さいもの",
            "    next_value(l, r, value): 区間[l, r) に含まれる要素のうち value以上の値(valueのこともあり得る)",
            "    \"\"\"",
            "    class BitVector:",
            "        def __init__(self, a:list):",
            "            self.n = len(a)",
            "            ra = [0]",
            "            for ai in a:",
            "                ra.append(ra[-1] + ai)",
            "            self.ra = ra    # 累積和",
            "        def rank0(self, r:int) -> int:",
            "            return r - self.rank1(r)",
            "        def rank1(self, r:int) -> int:",
            "            return self.ra[r]",
            "",
            "        def _bisect(l, r, isok):",
            "            while r - l > 1:",
            "                m = (l + r) >> 1",
            "                if isok(m): l = m",
            "                else: r = m",
            "            return l",
            "",
            "        def select0(self, k):",
            "            l, r = 0, self.n + 1",
            "            if not k < self.rank0(r-1): return -1",
            "            return self._bisect(l, r, lambda m: m-self.ra[m] <= k)",
            "",
            "        def select1(self, k):",
            "            l, r = 0, self.n + 1",
            "            if not k < self.ra[r-1]: return -1",
            "            return self._bisect(l, r, lambda m: self.ra[m] <= k)",
            "",
            "    def __init__(self, a, s=30):",
            "        self.n = len(a)",
            "        self.s = s # bit length",
            "        self.a = a",
            "        b = a[:]",
            "        self.x = []",
            "        for i in range(self.s)[::-1]:",
            "            l, r, t = [], [], []",
            "            for bi in b:",
            "                if bi >> i & 1:",
            "                    t.append(1); r.append(bi)",
            "                else:",
            "                    t.append(0); l.append(bi)",
            "            vb = self.BitVector(t)",
            "            self.x.append((vb.rank0(self.n), vb))",
            "            b = l + r",
            "        self.x = self.x[::-1]",
            "",
            "    def access(self, k):",
            "        \"\"\"",
            "        a[k]の値を取得:Number of value A[k]",
            "        \"\"\"",
            "        return self.a[k]",
            "",
            "    def rank(self, l, r, value):",
            "        \"\"\"",
            "        A[l,r)のうちvalueの個数:Number of value's in A[l,r)",
            "        \"\"\"",
            "        if l >= r: return 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return r - l",
            "",
            "    def select(self, value, k):",
            "        \"\"\"",
            "        valueのk番目(0index>k+1個目)のインデックス: Index of k'th value in a (zero indexed)",
            "        valueがk以下の場合は-1を返す",
            "        \"\"\"",
            "        if self.rank(0, self.n, value) <= k: return -1",
            "        ind = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                ind = z + vb.rank1(ind)",
            "            else:",
            "                ind = vb.rank0(ind)",
            "        ind += k",
            "        for i in range(self.s):",
            "            z, vb = self.x[i]",
            "            if ind < z:",
            "                ind = vb.select0(ind)",
            "            else:",
            "                ind = vb.select1(ind - z)",
            "        return ind",
            "",
            "    def freq(self, l, r, s, t):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値が[s, t)の範囲にあるものの個数",
            "        Number of elements in A[l,r) whose value is in [s, t)",
            "        \"\"\"",
            "        if s >= t: return 0",
            "        return self.freq_to(l, r, t) - self.freq_to(l, r, s)",
            "",
            "    def freq_to(self, l, r, value):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値が[0, value)の範囲にあるものの個数",
            "        Number of elements in A[l,r) whose value is in [0, u)",
            "        \"\"\"",
            "        if not value: return 0",
            "        if l >= r: return 0",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                ret += vb.rank0(r) - vb.rank0(l)",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return ret",
            "",
            "    def quantile(self, l, r, k):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値がk番目(0-ind>k+1番目)の値",
            "        k'th smallest in [l, r)",
            "        \"\"\"",
            "        if k >= r - l: return -1",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            zeros = vb.rank0(r) - vb.rank0(l)",
            "            if zeros > k:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "            else:",
            "                k -= zeros",
            "                ret |= 1 << i",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "        return ret",
            "",
            "    def kth_smallest(self, l, r, k):",
            "        return self.quantile(l, r, k)",
            "",
            "    def kth_largest(self, l, r, k):",
            "        return self.quantile(l, r, self.n-1-k)",
            "",
            "    def prev_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == 0: return -1",
            "        return self.kth_smallest(l, r, cnt - 1)",
            "",
            "    def next_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == r-l: return -1",
            "        return self.kth_smallest(l, r, cnt)",
            "",
            "",
            "#######################################",
            "from bisect import bisect_left",
            "class Compress:",
            "    \"\"\"一次元座標圧縮",
            "",
            "    Parameters",
            "    ----------",
            "    points : list",
            "    値のリスト [100,300,50,900,200]",
            "",
            "    Returns",
            "    -------",
            "    pos : {50: 0, 100: 1, 200: 2, 300: 3, 900: 4}",
            "    vals : {0: 50, 1: 100, 2: 200, 3: 300, 4: 900}",
            "    list : [1, 3, 0, 4, 2]",
            "    \"\"\"",
            "    def __init__(self, points, spacing=False, reverse=False):",
            "        pos, vals, sx = {}, {}, set(points)",
            "        if spacing: #スペースを作る場合",
            "            for p in points: sx.add(p+1)",
            "            sx.add(-1)",
            "            sx.add(10**10)",
            "",
            "        for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "            pos[xi], vals[i] = i, xi",
            "        self.pos, self.vals = pos, vals",
            "        self.original_list, self.list = points, [pos[xi] for xi in points]",
            "        self.valuesequence = sorted(self.pos.keys())",
            "",
            "    def __contains__(self, original_value):",
            "        return original_value in self.pos.keys()",
            "",
            "    def index(self, original_value):",
            "        # 元value -> 新index",
            "        # if original_value in self.pos: return self.pos[original_value]",
            "        # return None",
            "        return bisect_left(self.valuesequence, original_value)",
            "",
            "    def value(self, index):",
            "        # 新index -> 元value",
            "        if index in self.vals: return self.vals(index)",
            "        return None",
            "",
            "##########################################################################3",
            "",
            "class WaveletMatrixCompressed(WaveletMatrix):",
            "    def __init__(self, a, s=30):",
            "        self.cmp = Compress(a)",
            "        super().__init__(self.cmp.list, s)",
            "",
            "    def access(self, k):",
            "        cmppos = super().access(k)",
            "        return self.cmp.vals[cmppos]",
            "",
            "    def rank(self, l, r, value):",
            "        cmpidx = self.cmp.index(value)",
            "        return super().rank(l, r, cmpidx)",
            "",
            "    def select(self, value, k):",
            "        cmpidx = self.cmp.index(value)",
            "        return super().select(cmpidx, k)",
            "",
            "    def freq(self, l, r, s, t):",
            "        cmpsidx = self.cmp.index(s)",
            "        cmptidx = self.cmp.index(t)",
            "        if s >= t: return 0",
            "        return self.freq_to(l, r, t) - self.freq_to(l, r, s)",
            "",
            "    def freq_to(self, l, r, value):",
            "        cmpidx = self.cmp.index(value)",
            "        if not cmpidx: return 0",
            "        if l >= r: return 0",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if cmpidx >> i & 1:",
            "                ret += vb.rank0(r) - vb.rank0(l)",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return ret",
            "",
            "    def quantile(self, l, r, k):",
            "        if k >= r - l: return -1",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            zeros = vb.rank0(r) - vb.rank0(l)",
            "            if zeros > k:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "            else:",
            "                k -= zeros",
            "                ret |= 1 << i",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "        return self.cmp.vals[ret]",
            "",
            "    def kth_smallest(self, l, r, k):",
            "        return self.quantile(l, r, k)",
            "",
            "    def kth_largest(self, l, r, k):",
            "        return self.quantile(l, r, self.n-1-k)",
            "",
            "    def prev_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == 0: return -1",
            "        return self.kth_smallest(l, r, cnt - 1)",
            "",
            "    def next_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == r-l: return -1",
            "        return self.kth_smallest(l, r, cnt)",
            "",
            "",
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "",
            "# n, q = map(int, input().split())",
            "# a = list(map(int, input().split()))",
            "# wm = WaveletMatrix(a)",
            "# wm = WaveletMatrixCompressed(a)",
            "# for _ in range(q):",
            "#     l, r, k = map(int, input().split())",
            "#     print(wm.quantile(l, r, k))",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "q = int(input())",
            "wm = WaveletMatrixCompressed(a)",
            "for _ in range(q):",
            "    ret = 10**10",
            "    l, r, d = map(int, input().split())",
            "    r += 1",
            "    v = wm.prev_value(l, r, d)",
            "    if v != -1:",
            "        ret = min(ret, d-v)",
            "    v = wm.next_value(l, r, d)",
            "    if v != -1:",
            "        ret = min(ret, v-d)",
            "    print(ret)",
            ""
        ],
        "description": [
            "WaveletMatrix: 数列のある範囲での値の頻度やインデックスを求める"
        ],
        "scope": "python"
    },
    "累積和": {
        "prefix": [
            "Lib_D_累積和_accum"
        ],
        "body": [
            "class Imos:",
            "    def __init__(self, h, w):",
            "        self.h = h",
            "        self.w = w",
            "        # 拡張grid生成",
            "        self.grid = [[0] * (w+1) for _ in range(h+1)]",
            "",
            "    def import_grid(self, grid):",
            "        for i in range(self.h):",
            "            for j in range(self.w):",
            "                self.grid_add(i, j, grid[i][j])",
            "",
            "    def grid_add(self, i, j, value):",
            "        # i, j is 0 index on original_grid",
            "        self.grid[i+1][j+1] += value",
            "",
            "    def accumlate(self):",
            "        # 累積和",
            "        for i in range(self.h+1):",
            "            for j in range(1, self.w+1):",
            "                self.grid[i][j] += self.grid[i][j-1]",
            "        for j in range(self.w+1):",
            "            for i in range(1, self.h+1):",
            "                self.grid[i][j] += self.grid[i-1][j]",
            "",
            "    def sum(self, x, y, u, v):",
            "        # x <= i < u, y <= j < v　の範囲をカウント",
            "        if not 0<= x <= u < self.h+1: return 0",
            "        if not 0<= y <= v < self.w+1: return 0",
            "        gd = self.grid",
            "        return gd[u][v] - gd[u][y] - gd[x][v] + gd[x][y]",
            "",
            "###############################################",
            "h, w, n = map(int, input().split())",
            "im = Imos(h, w)",
            "for _ in range(n):",
            "    a, b, c, d = map(int, input().split())",
            "    im.grid_add(a-1, b-1, 1)",
            "    im.grid_add(c, d, 1)",
            "    im.grid_add(a-1, d, -1)",
            "    im.grid_add(c, b-1, -1)",
            "",
            "im.accumlate()",
            "for i in range(im.h):",
            "    print(*im.grid[i][:-1])",
            ""
        ],
        "description": [
            "累積和"
        ],
        "scope": "python"
    },
    "二部グラフ判定": {
        "prefix": [
            "Lib_G_二部グラフ判定_bipartite"
        ],
        "body": [
            "",
            "import sys",
            "sys.setrecursionlimit(10**9)",
            "",
            "######################################",
            "# 二部グラフ(bipartite graph)",
            "# 頂点集合を2つに分割して各部分の頂点は互いに隣接しないようにできるグラフ",
            "# ノード2色を塗って、辺の両端は異なるようにできるか",
            "######################################",
            "######################################",
            "# 再帰版",
            "######################################",
            "# 深さ優先探索",
            "def is_bipartite(g, v, c):",
            "    global color",
            "    color[v] = c    # 色を塗る",
            "    for nv in g[v]: # 次のノードの探索",
            "        # すでに隣接の色が確定していて同じ色となっている場合終了",
            "        if color[nv] == c: return False",
            "        # 未確定の倍は反転させた色を塗って探索した結果を受け取る",
            "        if color[nv] == 0 and not is_bipartite(g, nv, -c): return False",
            "    return True",
            "",
            "",
            "######################################",
            "# 非再帰版",
            "######################################",
            "def is_bipartite(g, st, c):",
            "    global color",
            "    # 深さ優先探索",
            "    q = [(st, c)]",
            "    while q:",
            "        v, c = q.pop()",
            "        color[v] = c    # 色を塗る",
            "        for nv in g[v]: # 次のノードの探索",
            "            # すでに隣接の色が確定していて同じ色となっている場合終了",
            "            if color[nv] == c: return False",
            "            # 未確定の倍は反転させた色でキューに入れる",
            "            if color[nv] == 0:",
            "                q.append((nv, -c))",
            "    return True",
            "",
            "#######################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "color = [0] * n     # 0:未確定 1:黒 -1:白",
            "",
            "# 隣接リストの作成",
            "for i in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "print(is_bipartite(G, 0, 1))",
            ""
        ],
        "description": [
            "隣接リストから二部グラフかどうか判定"
        ],
        "scope": "python"
    },
    "Graph二部マッチング": {
        "prefix": [
            "Lib_G_二部マッチング_bipartitematching"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "##二部マッチング",
            "",
            "class BipartileMatching:",
            "    ##L2R:Lから見たRのマッチングを記録",
            "    ##R2L:Rから見たLのマッチングを記録",
            "    ##backpath:L側に逆辺が張られている場合の辿る先",
            "    ##root:逆辺を考慮したLの始点を記録",
            "",
            "    def __init__(self, L, R):",
            "        self.L = L",
            "        self.R = R",
            "        self.G = [[] for _ in range(L)]",
            "        self.L2R = None",
            "        self.R2L = None",
            "",
            "    def add_edge(self, u, v):",
            "        self.G[u].append(v)",
            "",
            "    @property",
            "    def matching(self):",
            "        L = self.L",
            "        R = self.R",
            "        L2R = [-1] * L",
            "        R2L = [-1] * R",
            "        backpath = [-1] * L",
            "        root = [-1] * L",
            "        res, f = 0, True",
            "        while f:",
            "            f = False",
            "            q=deque()",
            "            for i in range(L):",
            "                ##まだマッチング対象が見つかっていなければ",
            "                ##iを始点としてキューに追加",
            "                if L2R[i] == -1:",
            "                    root[i] = i",
            "                    q.append(i)",
            "",
            "            while q:",
            "                s = q.popleft()",
            "                ##逆辺を辿った先のrootが-1になっていればcontinue",
            "                if ~L2R[root[s]]: continue",
            "",
            "                ##始点から接続されている辺を全探索する",
            "                for t in self.G[s]:",
            "                    if R2L[t] == -1:",
            "                        ##逆辺が存在する場合は辿っていく",
            "                        while t != -1:",
            "                            R2L[t] = s",
            "                            L2R[s], t = t , L2R[s]",
            "                            s = backpath[s]",
            "                        f = True",
            "                        res += 1",
            "                        break",
            "",
            "                    ##仮のtに対するマッチング候補の情報を更新しキューに追加する",
            "                    temps = R2L[t]",
            "                    if ~backpath[temps]: continue",
            "                    backpath[temps] = s",
            "                    root[temps] = root[s]",
            "                    q.append(temps)",
            "",
            "            ##更新があれば逆辺・始点情報を初期化する",
            "            if f:",
            "                backpath = [-1] * L",
            "                root = [-1] * L",
            "        self.L2R = L2R",
            "        self.R2L = R2L",
            "        return res",
            "",
            "#################################",
            "n, m, e = map(int, input().split())",
            "BM = BipartileMatching(n, m)",
            "for i in range(e):",
            "    x, y = map(int, input().split())",
            "    BM.add_edge(x, y)",
            "print(BM.matching)",
            ""
        ],
        "description": [
            "Graph二部マッチング"
        ],
        "scope": "python"
    },
    "トポロジカルソート 有向グラフ": {
        "prefix": [
            "Lib_GD_トポロジカルソート_topologicalsort"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "class topological_sort:",
            "    def __init__(self, n:int, G) -> None:",
            "        self.n = n",
            "        self.ts = []            # トポロジカルソート",
            "        self.parents = [-1] * n # 親 -1は根",
            "        self.G = G              # 辺",
            "        self.in_cnt = [0] * n   # 入力",
            "        self.node_zero = []     # ゼロ次のノード",
            "        for i, gi in enumerate(G):",
            "            for j, _ in gi:",
            "                self.in_cnt[j] += 1",
            "        self.node_zero = [i for i in range(self.n) if self.in_cnt[i] == 0]",
            "",
            "",
            "    def _build_sort_by_appear(self) -> None:",
            "        q = self.node_zero[:]",
            "        q = deque(q)",
            "        while q:",
            "            p = q.popleft()",
            "            self.ts.append(p)",
            "            for nxt, _ in self.G[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    q.append(nxt)",
            "                    self.parents[nxt] = p",
            "",
            "",
            "    def _build_sort_by_nodeid(self) -> None:",
            "        from heapq import heapify, heappop, heappush",
            "        q = self.node_zero[:]",
            "        heapify(q)",
            "        while q:",
            "            p = heappop(q)",
            "            self.ts.append(p)",
            "            for nxt, nxtw in self.G[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    heappush(q, nxt)",
            "                    self.parents[nxt] = p",
            "",
            "",
            "    def build(self, sorttype='appear'):",
            "        self.ts = []            # トポロジカルソート",
            "        if sorttype == 'appear':        # 出たとこ順番",
            "            self._build_sort_by_appear()",
            "        elif sorttype == 'nodeid':      # ノードの順番",
            "            self._build_sort_by_nodeid()",
            "",
            "",
            "    @property",
            "    def is_dag(self) -> bool:",
            "        return len(self.ts)==self.n",
            "        # True 閉路なしDAG",
            "        # False 閉路あり",
            "",
            "",
            "    @property",
            "    def is_unique(self) -> bool:",
            "        if not self.is_dag: return False",
            "        for i in range(self.n-1):",
            "            u, v = self.ts[i:i+2]",
            "            if not v in self.G[u]: return False",
            "        return True",
            "        # True トポロジカルソートの経路が一意",
            "        # False 複数あり",
            "",
            "",
            "#########################################",
            "# n, m = map(int, input().split())",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "m = n",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    w = 0",
            "    G[a].append(b)",
            "",
            "ts = topological_sort(n, G)",
            "",
            "ts.build()",
            "",
            "print(ts.ts)",
            "print(ts.parents)",
            "print(ts.is_dag)",
            "print(ts.is_unique)",
            ""
        ],
        "description": [
            "トポロジカルソート topologicalsort"
        ],
        "scope": "python"
    },
    "強連結成分分解": {
        "prefix": [
            "Lib_GD_強連結成分分解_SCC"
        ],
        "body": [
            "from atcoder.scc import SCCGraph as _SCCG",
            "",
            "class SCCGraph(_SCCG):",
            "    def __init__(self, n):",
            "        super().__init__(n)",
            "        self.n = None       # 連結成分の個数",
            "        self.ids = None     # nodeが、どのグループに属するか",
            "        self.groups = None  # グループに属するもとのnode",
            "        self.G = None       # 縮約後の隣接リスト",
            "",
            "    def scc(self):",
            "        n, ids = self._internal.scc_ids()",
            "        groups = [[] for _ in range(n)]",
            "        for i in range(self._internal._n):",
            "            groups[ids[i]].append(i)",
            "        self.n = n",
            "        self.ids = ids",
            "        self.groups = groups",
            "        return n, ids, groups",
            "",
            "    def dag(self):",
            "        self.G = [set() for _ in range(self.n)]",
            "        for fm, to in self._internal._edges:",
            "            fm = self.ids[fm]; to = self.ids[to]",
            "            if fm != to:",
            "                self.G[fm].add(to)",
            "        return self.G",
            "",
            "n, m = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "scc = SCCGraph(n)",
            "",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    if A[a] <= A[b]:",
            "        scc.add_edge(a, b)",
            "    if A[a] >= A[b]:",
            "        scc.add_edge(b, a)",
            "",
            "scc.scc()",
            "scc.dag()",
            "",
            "# 強連結成分分解(SCC): グラフに対するSCCを行う",
            "# https://hkawabata.github.io/technical-note/note/Algorithm/graph/scc.html",
            "# 有向グラフで、互いに行き来できる連結成分を分類する",
            "# 元の有向グラフが DAG でなくとも、そのグラフの SCC は DAG を形成する",
            "# 作り方",
            "# 適当に選んだ頂点から深さ優先（帰りがけ探索）し、1から番号を増やしながらラベリング：",
            "# エッジをすべて逆向きにしたグラフを用意：",
            "# 頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "# 未探索の頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "",
            "# https://atcoder.jp/contests/practice2/tasks/practice2_g",
            ""
        ],
        "description": [
            "強連結成分分解(SCC): グラフに対するSCCを行う"
        ],
        "scope": "python"
    },
    "最大フロー": {
        "prefix": [
            "Lib_GD_最大フロー_maximumflow_dinic"
        ],
        "body": [
            "",
            "# 最大流問題",
            "# 始点sと終点tが区別された有向グラフ",
            "# 各辺(u,v)には容量c(u,v)が設定されており、超えないフローが流れます。",
            "# 始点sから終点tへの最大流を求める。",
            "#",
            "# Dinic's algorithm",
            "# 幅優先探索で水を流す向きをざっと決める．",
            "# 深さ優先探索で決められた向きで流せる経路を探し，水を流す．",
            "# 流せなくなったら1に戻る.",
            "# O(∣V∣**2・∣E∣), O(∣V+E∣・E**0.5 辺が全て1の時)",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_6_A",
            "",
            "# https://github.com/not522/ac-library-python/blob/master/atcoder/maxflow.py",
            "# https://github.com/atcoder/ac-library/blob/master/document_ja/maxflow.md",
            "# Edge",
            "# __init__(n)",
            "# add_edge(src, dst, cap)",
            "# flow(s, t, flow_limit)",
            "# (1) 頂点 から へ流せる限り流し、流せた量を返す。",
            "# (2) 頂点 から へ流量 flow_limit に達するまで流せる限り流し、流せた量を返す。",
            "# change_edge(i, newcap, newflow)",
            "# edges(): 辺の情報",
            "# min_cut(s)",
            "from atcoder.maxflow import MFGraph",
            "",
            "#############",
            "n, m = map(int, input().split())",
            "mf = MFGraph(n)",
            "for _ in range(m):",
            "    a, b, e = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    mf.add_edge(a, b, e)",
            "",
            "print(mf.max_flow(0, n-1))",
            ""
        ],
        "description": [
            "最大フローO(∣V∣**2・∣E∣)"
        ],
        "scope": "python"
    },
    "最小費用流": {
        "prefix": [
            "Lib_GD_最小費用流_mincostflow"
        ],
        "body": [
            "",
            "# 最小費用流問題",
            "# 各辺に容量とコストが設定されたフローネットワークにおいて、",
            "# 始点s から終点t まで流量F のフローを流すための最小コストを求める",
            "# Minimum Cost Flow : O(FElogV) ダイクストラ",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_6_B",
            "# https://atcoder.jp/contests/practice2/tasks/practice2_d",
            "",
            "# https://github.com/not522/ac-library-python/blob/master/atcoder/mincostflow.py",
            "# https://github.com/atcoder/ac-library/blob/master/document_ja/mincostflow.md",
            "# Edge",
            "# __init__(n)",
            "# add_edge(src, dst, cap, cost)",
            "# flow(s, t, flow_limit)",
            "# (1) 頂点 から へ流せる限り流し、流せた量とコストを返す。",
            "# (2) 頂点 から へ流量 flow_limit に達するまで流せる限り流し、流せた量とコストを返す。",
            "# change_edge(i, newcap, newflow)",
            "# edges(): 辺の情報",
            "# min_cut(s)",
            "from atcoder.mincostflow import MCFGraph",
            "",
            "#############",
            "n, m, f = map(int, input().split())",
            "mf = MCFGraph(n)",
            "for _ in range(m):",
            "    u, v, cap, cost = map(int, input().split())",
            "    mf.add_edge(u, v, cap, cost)",
            "",
            "print(mf.min_cost_flow(0, n-1, f))",
            ""
        ],
        "description": [
            "最小費用流を算出するO(FElogV) ダイクストラ"
        ],
        "scope": "python"
    },
    "LCA": {
        "prefix": [
            "Lib_GT_最小共通祖先_LCA"
        ],
        "body": [
            "from collections import deque",
            "class Lca:",
            "    \"\"\"Lowest Common Ancestor",
            "",
            "    u, vの共通の親",
            "    ダブリング p[i][v] = vの2^i個 親",
            "",
            "    Parameters",
            "    ----------",
            "    n : int",
            "        nodeの数",
            "    G : graph",
            "    r : root",
            "    \"\"\"",
            "    def __init__(self, n: int, G, r:int) -> None:",
            "        self.n = n",
            "        self.root = r",
            "        self.edges = G",
            "        self.lv = n.bit_length()",
            "        self.p = [[None] * n for _ in range(self.lv)]",
            "        self.maxcost = [[0] * n for _ in range(self.lv)]",
            "        self._depth = [None] * n",
            "        self._costs = [None] * n",
            "        self.memodist = dict()",
            "        self.memocost = dict()",
            "        self.build()",
            "",
            "    def build(self):",
            "        \"\"\"深さと親の設定とダブリング",
            "        \"\"\"",
            "        # 深さと親の設定",
            "        r = self.root",
            "        q = deque([r])",
            "        self._depth[r], self._costs[r], self.p[0][r], self.maxcost[0][r] = 0, 0, r, 0",
            "        while q:",
            "            cur = q.popleft()",
            "            dep = self._depth[cur]",
            "            dis = self._costs[cur]",
            "            for nxt in self.edges[cur]:",
            "                if type(nxt) != int:",
            "                    nxt, cost = nxt",
            "                else:",
            "                    cost = 1",
            "                if self.p[0][nxt] != None: continue",
            "                q.append(nxt)",
            "                self._depth[nxt], self._costs[nxt], self.p[0][nxt], self.maxcost[0][nxt] = dep + 1, dis + cost, cur, cost",
            "        # ダブリング",
            "        for i in range(1, self.lv):",
            "            for v in range(self.n):",
            "                nv = self.p[i-1][v]",
            "                self.p[i][v] = self.p[i-1][nv]",
            "                self.maxcost[i][v] = max(self.maxcost[i-1][v], self.maxcost[i-1][nv])",
            "",
            "",
            "    def _lca(self, u, v):",
            "        \"\"\"共通祖先, 最大辺",
            "        Parameters",
            "        ----------",
            "        u, v : node",
            "            ノード",
            "        Returns",
            "        -------",
            "        int, int",
            "            共通祖先のノード, 最大辺",
            "        \"\"\"",
            "        _max_cost = 0",
            "        # u,vの高さを合わせる",
            "        if self._depth[u] < self._depth[v]: u, v = v, u",
            "        for i in range(self.lv):",
            "            if self._depth[u] - self._depth[v] >> i & 1:",
            "                _max_cost = max(_max_cost, self.maxcost[i][u])",
            "                u = self.p[i][u]",
            "        if u == v: return u, _max_cost",
            "        # u, vのギリギリ合わない高さまで昇る",
            "        for i in range(self.lv)[::-1]:",
            "            if self.p[i][u] != self.p[i][v]:",
            "                _max_cost = max(_max_cost, self.maxcost[i][u], self.maxcost[i][v])",
            "                u = self.p[i][u]",
            "                v = self.p[i][v]",
            "        return self.p[0][u], max(_max_cost, self.maxcost[0][u], self.maxcost[0][v])",
            "",
            "",
            "    def lca(self, u, v):",
            "        return self._lca(u, v)[0]",
            "",
            "",
            "    def max_cost(self, u, v):",
            "        return self._lca(u, v)[1]",
            "",
            "",
            "    def distance(self, u, v):",
            "        if not (u, v) in self.memodist:",
            "            lca = self.lca(u, v)",
            "            self.memodist[(u, v)] = self._depth[u] + self._depth[v] - 2 * self._depth[lca]",
            "        return self.memodist[(u, v)]",
            "",
            "",
            "    def cost(self, u, v):",
            "        if not (u, v) in self.memocost:",
            "            lca = self.lca(u, v)",
            "            self.memocost[(u, v)] = self._costs[u] + self._costs[v] - 2 * self._costs[lca]",
            "        return self.memocost[(u, v)]",
            "",
            "",
            "    def _la(self, x, h):",
            "        \"\"\"h代前祖先",
            "        \"\"\"",
            "        for i in range(self.lv)[::-1]:",
            "            if h >= 1 << i:",
            "                x = self.p[i][x]",
            "                h -= 1 << i",
            "        return x",
            "",
            "",
            "    def jump(self, u, v, i):",
            "        \"\"\"",
            "        u -> vへのパスのk番目の頂点",
            "        \"\"\"",
            "        c = self.lca(u, v)",
            "        du = self._depth[u]",
            "        dv = self._depth[v]",
            "        dc = self._depth[c]",
            "",
            "        path_len = du - dc + dv - dc",
            "        if path_len < i:",
            "            return -1",
            "",
            "        if du - dc >= i:",
            "            return self._la(u, i)",
            "",
            "        return self._la(v, path_len - i)",
            "",
            "########################################",
            "",
            "# n, q = map(int, input().split())",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "lca = Lca(n, G, 0)",
            "q = int(input())",
            "for _ in range(q):",
            "    u, v = map(int, input().split())",
            "    u -= 1; v -= 1",
            "    # u, v, k = map(int, input().split())",
            "    # print(lca.jump(u, v, k))",
            "    print(lca.distance(u, v)+1)",
            ""
        ],
        "description": [
            "最小共通祖先"
        ],
        "scope": "python"
    },
    "オイラーツアー eulartour 再帰版": {
        "prefix": [
            "Lib_GT_オイラーツアー_再帰版_eulartour"
        ],
        "body": [
            "# オイラーツアー eulartour 再帰版",
            "# 木をDFSしたときの順番で頂点を記録する手法",
            "# pre-order : 頂点に到着したら記録",
            "# post-order : 頂点から離れるときに記録",
            "# - 根付き木のある頂点からの部分木に対するクエリを処理",
            "# - ある頂点がある頂点の部分木に含まれるかを高速に判定する",
            "# - 上手くオイラーツアーを作るとパスのコストの総和が取れる",
            "# n = 5",
            "# 0",
            "# |",
            "# 1",
            "# |",
            "# 2",
            "# |  \\",
            "# 4  3",
            "#",
            "# etnodes = [0,1,2,4,2,3,2,1,0]",
            "# etdepth = [0,1,2,3,2,3,2,1,0]",
            "# etdetL = [0,1,2,5,3]",
            "# etdetR = [9,8,7,6,4]",
            "",
            "",
            "class EulerTour():",
            "    def __init__(self, n, G):",
            "        self.n = n",
            "        self.edges = G",
            "        self.root = None    # 根",
            "        self.etnodes = []    # i番目の頂点番号",
            "        self.etedges = []    # i番目の辺の番号",
            "        self.etL = [-1] * n  # in time",
            "        self.etR = [-1] * n  # out time",
            "        self.depthbynodes = [0] * n",
            "        self.etdepth = []       # i番目の頂点番号の深さ",
            "",
            "",
            "    def set_euler_tour(self, root):",
            "        self.root = root        # 根を設定して",
            "        self._dfs(root)",
            "        self._set_timestamp()",
            "",
            "    def _dfs(self, cur, last=-1):",
            "        ################## 行きがけ処理",
            "        depth = 0",
            "        if last != -1:",
            "            depth = self.depthbynodes[last] + 1",
            "        self.depthbynodes[cur] = depth",
            "        self.etnodes.append(cur)",
            "        self.etdepth.append(depth)",
            "",
            "        for nxt in self.edges[cur]:",
            "            if nxt == last: continue",
            "            self._dfs(nxt, cur)",
            "            ################## 帰りがけ処理",
            "            self.etnodes.append(cur)",
            "            self.etdepth.append(depth)",
            "",
            "",
            "    def _set_timestamp(self):",
            "        for ct, now in enumerate(self.etnodes):",
            "            if self.etL[now] == -1:",
            "                self.etL[now] = ct",
            "            self.etR[now] = ct + 1",
            "",
            "",
            "#########################################",
            "def int1(x): return int(x)-1",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "#    a, b = map(int1, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "T = EulerTour(n, G)",
            "",
            "T.set_euler_tour(0)",
            "print(T.etnodes)",
            "print(T.etedges)",
            "print(T.etdepth)",
            "",
            "print(T.etL)",
            "print(T.etR)",
            "print(T.depthbynodes)",
            "",
            "\"\"\"",
            "8",
            "0 6",
            "0 5",
            "6 4",
            "5 2",
            "5 1",
            "5 7",
            "2 3",
            "\"\"\"",
            ""
        ],
        "description": [
            "オイラーツアー eulartour 再帰版"
        ],
        "scope": "python"
    },
    "全方位木DP": {
        "prefix": [
            "Lib_GT_全方位木DP"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "class Tree:",
            "    def __init__(self, n, E):",
            "        self.n = n",
            "        self.root = None    # 根",
            "        self.depth = None   # 深さ",
            "        self.par = None     # 親",
            "        self.order = None   # 深さ優先探索の行きがけ順",
            "        self.dp = None",
            "        self.dp1 = None",
            "        self.edges = [[] for _ in range(n)]",
            "        for a, b in E:",
            "            self.edges[a].append(b)",
            "            self.edges[b].append(a)",
            "",
            "",
            "    def set_root(self, root):",
            "        self.depth = [-1] * self.n",
            "        self.par = [-1] * self.n",
            "        self.order = []",
            "        self.root = root",
            "        self.depth[root] = 0",
            "        self.order.append(root)",
            "        nxt_q = deque([root])",
            "        while nxt_q:",
            "            p = nxt_q.pop() # 深さ優先探索",
            "            for q in self.edges[p]:",
            "                if self.depth[q] != -1: continue",
            "                self.par[q] = p",
            "                self.depth[q] = self.depth[p] + 1",
            "                self.order.append(q)",
            "                nxt_q.append(q)",
            "        # self.size = [1] * n # 部分木のノード数",
            "        # for p in self.order[::-1]:",
            "        #     for q in self.edges[p]:",
            "        #         if self.par[p] == q: continue",
            "        #         self.size[p] += self.size[q]",
            "",
            "    def rerooting(self, merge, op, fin, id):",
            "        if self.root == None: self.set_root(0)",
            "        dp1 = [id] * self.n",
            "        dp2 = [id] * self.n",
            "        for p in self.order[::-1]:",
            "            t = id",
            "            for q in self.edges[p]:",
            "                if self.par[p] == q: continue",
            "                dp2[q] = t",
            "                t = merge(t, op(dp1[q], p, q))",
            "            t = id",
            "            for q in self.edges[p][::-1]:",
            "                if self.par[p] == q: continue",
            "                dp2[q] = merge(t, dp2[q])",
            "                t = merge(t, op(dp1[q], p, q))",
            "            dp1[p] = t",
            "        self.dp1 = dp1[:]",
            "        for q in self.order[1:]:",
            "            pq = self.par[q]",
            "            dp2[q] = op(merge(dp2[q], dp2[pq]), q, pq)",
            "            dp1[q] = merge(dp1[q], dp2[q])",
            "        for q in self.order:",
            "            pq = self.par[q]",
            "            dp1[q] = fin(dp1[q], pq, q)",
            "        self.dp = dp1[:]",
            "        return dp1",
            "",
            "",
            "#####################################",
            "# a, bはdpの値, pは考察している辺の親, qは子",
            "# merge: dpをmerge",
            "# op: dpをmerge前にする作業",
            "# fin: dpをmerge後にする作業",
            "# ie: mergeの単位元",
            "#####################################",
            "",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/abc160/tasks/abc160_f",
            "",
            "n = int(input())",
            "E = [tuple(map(lambda x: int(x)-1 , input().split())) for _ in range(n-1)]",
            "T = Tree(n, E)",
            "",
            "mod, lim = 1000000007, n + 1",
            "g1, g2 = [[1]*(lim+1) for _ in range(2)]",
            "for i in range(2, lim + 1):",
            "    g1[i] = g1[i-1] * i % mod",
            "g2[-1] = pow(g1[-1], mod-2, mod)",
            "for i in range(lim, 0, -1):",
            "    g2[i-1] = g2[i] * i % mod",
            "",
            "def fac(n): return g1[n]",
            "def facinv(n): return g2[n]",
            "",
            "merge = lambda a, b: (a[0] * b[0] * facinv(a[1]) * facinv(b[1]) * fac(a[1]+b[1]) % mod, (a[1] + b[1]) % mod)",
            "op = lambda a, p, q: (a[0], (a[1] + 1) %mod)",
            "fin = lambda a, p, q: a",
            "id = (1, 0)",
            "",
            "ret = [dpi[0] for dpi in T.rerooting(merge, op, fin, id)]",
            "print(\"\\n\".join(map(str, ret)))",
            "",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/s8pc-4/tasks/s8pc_4_d",
            "",
            "n = int(input())",
            "E = [tuple(map(lambda x: int(x)-1 , input().split())) for _ in range(n-1)]",
            "T = Tree(n, E)",
            "# a, bはdpの値, pは考察している接点親, qは子",
            "# dpをmerge",
            "merge = lambda a, b: a + b",
            "# dpをmerge前にする作業",
            "op = lambda a, p, q: a / (len(T.edges[q])-1) + 1 if a != 0 else 1",
            "# dpをmerge後にする作業",
            "fin = lambda a, p, q: a / len(T.edges[q])",
            "# mergeの単位元",
            "id = 0",
            "",
            "ret = T.rerooting(merge, op, fin, id)",
            "print(\"\\n\".join(map(str, ret)))",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/abc222/tasks/abc222_f",
            "",
            "n = int(input())",
            "E = []",
            "cost = {}",
            "for _ in range(n-1):",
            "    a, b, c = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    E.append((a, b))",
            "    cost[(a, b)] = c",
            "    cost[(b, a)] = c",
            "D = list(map(int, input().split()))",
            "",
            "T = Tree(n, E)",
            "",
            "merge = lambda a, b: max(a, b)",
            "# dpをmerge前にする作業",
            "op = lambda a, p, q: max(a, D[q]) + cost[(p, q)]",
            "# dpをmerge後にする作業",
            "fin = lambda a, p, q: a",
            "# mergeの単位元",
            "id = 0",
            "",
            "ret = T.rerooting(merge, op, fin, id)",
            "print(\"\\n\".join(map(str, ret)))",
            "",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/abc348/tasks/abc348_e",
            "",
            "n = int(input())",
            "E = [tuple(map(lambda x: int(x)-1 , input().split())) for _ in range(n-1)]",
            "C = list(map(int, input().split()))",
            "T = Tree(n, E)",
            "",
            "# a, bはdpの値, pは考察している接点親, qは子",
            "# dpをmerge",
            "merge = lambda a, b:  (a[0]+b[0], a[1]+b[1])",
            "# dpをmerge前にする作業",
            "op = lambda a, p, q: (a[0] + C[q], a[0] + a[1] + C[q])",
            "# dpをmerge後にする作業",
            "fin = lambda a, p, q: a",
            "# mergeの単位元",
            "id = (0, 0)",
            "",
            "ret = min(dpi[1] for dpi in T.rerooting(merge, op, fin , id))",
            "print(ret)",
            "",
            "#######################################################",
            "",
            ""
        ],
        "description": [
            "全方位木DP",
            "https://algo-logic.info/tree-dp/"
        ],
        "scope": "python"
    },
    "最小全域木": {
        "prefix": [
            "Lib_GT_最小全域木_MST"
        ],
        "body": [
            "from atcoder.dsu import DSU",
            "",
            "class Kruskal:",
            "    def __init__(self, n:int, G:list)->None:",
            "        self.n = n",
            "        self.all_edges = G",
            "        self.edges = [False] * len(G)",
            "        self.G = [[] for _ in range(n)]",
            "        self.weight = 0",
            "        self.nodes = set([])",
            "        self.INF = 10**20",
            "        self.build()",
            "",
            "    def build(self)->None:",
            "        uf = DSU(self.n)",
            "        for u, v, w, i in sorted([(a, b, w, i) for i, (a, b, w) in enumerate(self.all_edges)], key=lambda x: x[2]):",
            "            if not uf.same(u, v):",
            "                uf.merge(u, v)",
            "                self.weight += w",
            "                self.nodes |= {u, v}",
            "                self.edges[i] = True",
            "                self.G[u].append((v, w))",
            "                self.G[v].append((u, w))",
            "        if sum(self.edges) != self.n - 1:   #",
            "            self.weight = self.INF",
            "################################",
            "",
            "n, m = map(int, input().split())",
            "",
            "#辺リストの作成",
            "G = []",
            "for i in range(m):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G.append((a, b, w))",
            "",
            "mst = Kruskal(n, G)",
            "print(mst.weight)",
            ""
        ],
        "description": [
            "最小全域木 クラスカル法 minimum_spanning_tree",
            "重み付き無向グラフで、それらの全ての頂点を結び連結するような木の最小のコストを求める",
            "辺の重みの小さい順にみて、連結成分が閉路にならない辺を追加していく",
            "つなぐ頂点が同じ連結成分にないことをUnion Find Tree でみる"
        ],
        "scope": "python"
    },
    "Diameter": {
        "prefix": [
            "Lib_GT_木の直径"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "def _bfs(n, G, root=0):",
            "    _depth = [None] * n",
            "    q = deque()",
            "    q.append(root)",
            "    _depth[root] = 0",
            "    _parent = [None] * n",
            "    farest_dist = 0",
            "    farest_node = 0",
            "    while q:",
            "        cur = q.popleft()",
            "        dep = _depth[cur]",
            "        for nxt in G[cur]:",
            "            nx, cost = nxt",
            "            if _depth[nx] != None: continue",
            "            q.append(nx)",
            "            newdep = dep + cost",
            "            _depth[nx] = newdep",
            "            if newdep > farest_dist:",
            "                farest_dist = newdep",
            "                farest_node = nx",
            "    return farest_node, farest_dist, _depth, _parent",
            "",
            "",
            "def tree_diameter(n, G):",
            "    u, *_ = _bfs(n, G, 0)",
            "    v, diam, depth, parent = _bfs(n, G, u)",
            "    return u, v, diam, depth, parent",
            "",
            "",
            "def tree_heights(n, G):",
            "    u, *_ = _bfs(n, G, 0)",
            "    v, _, depthu, _ = _bfs(n, G, u)",
            "    _, __, depthv, __ = _bfs(n, G, v)",
            "    return [max(x, y) for x, y in zip(depthu, depthv)]",
            "",
            "",
            "##############################",
            "",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            "",
            "print(tree_diameter(n, G))",
            "print(tree_heights(n, G))",
            "",
            ""
        ],
        "description": [
            "木の直径"
        ],
        "scope": "python"
    },
    "トポロジカルソート木": {
        "prefix": [
            "Lib_GT_木トポロジカルソート_topologicalsort"
        ],
        "body": [
            "# トポロジカルソート",
            "# 有向非巡回グラフ（DAG）の各ノードを順序付けして、どのノードもその出力辺の先のノードより前にくるように並べることである。",
            "# 有向非巡回グラフは必ずトポロジカルソートすることができる。",
            "from collections import deque",
            "",
            "class topological_sort:",
            "    def __init__(self, n:int, G) -> None:",
            "        self.n = n",
            "        self.ts = []            # トポロジカルソート",
            "        self.parents = [-1] * n # 親 -1は根",
            "        self.G = G              # 辺",
            "        self.childrens = G.copy() # 辺",
            "",
            "",
            "    def build(self, root):",
            "        que = deque([root])",
            "        self.ts = []            # トポロジカルソート",
            "        while que:",
            "            x = que.popleft()",
            "            self.ts.append(x)",
            "            for nx in self.G[x]:",
            "                if nx == self.parents[x]: continue",
            "                self.parents[nx] = x",
            "                self.childrens[nx].remove(x)",
            "                que.append(nx)",
            "",
            "#########################################",
            "# n, m = map(int, input().split())",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "m = n",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    w = 0",
            "    G[a].append((b, w))",
            "",
            "ts = topological_sort(n, G)",
            "",
            "ts.build(0)",
            "",
            "print(ts.ts)",
            "print(ts.parents)",
            "",
            "# 木dp  #ノードに1を置いて葉から合計する",
            "dp = [1] * n",
            "for i in ts.ts[::-1]:  #葉から",
            "    for j in ts.childrens[i]:",
            "        dp[i] += dp[j]",
            "",
            ""
        ],
        "description": [
            "木トポロジカルソート topologicalsort"
        ],
        "scope": "python"
    },
    "木の上の範囲クエリ": {
        "prefix": [
            "Lib_GT_木上の辺の１点更新区間クエリ_RangeQuery"
        ],
        "body": [
            "#############################################",
            "# 木の上で経路上の範囲クエリするもの",
            "# https://atcoder.jp/contests/abc294/tasks/abc294_g",
            "",
            "class SegmentTree:",
            "    def __init__(self, init, f, ie):",
            "        # initがリストなら初期化, 整数ならinit個の配列",
            "        self._f = f",
            "        self._ie = ie",
            "        if type(init) == int:",
            "            init = [ie] * init",
            "        self._n = len(init)",
            "        self._log = (self._n - 1).bit_length()",
            "        self._size = 1 << self._log",
            "        self._dat = [ie] * self._size + init + [ie] * (self._size - len(init))",
            "        for i in range(self._size-1, 0, -1): self._update(i)",
            "",
            "    def _update(self, i):",
            "        self._dat[i] = self._f(self._dat[i<<1], self._dat[(i<<1)+1])",
            "",
            "    def __getitem__(self, i):",
            "        return self._dat[i + self._size]",
            "",
            "    def __str__(self):",
            "        return ' '.join(map(str, (self[i] for i in range(self._n))))",
            "",
            "    def update(self, i, x):",
            "        # one point update  a[i] を xに更新",
            "        i += self._size",
            "        self._dat[i] = x",
            "        while i:",
            "            i >>= 1",
            "            self._update(i)",
            "",
            "    def add(self, i, x):",
            "        # one point update a[i] に xを加算",
            "        i += self._size",
            "        self._dat[i] += x",
            "        while i:",
            "            i >>= 1",
            "            self._update(i)",
            "",
            "    def query(self, l, r):",
            "        # 半開区間[l, r)にf(a[l], a[l+1])演算",
            "        l += self._size",
            "        r += self._size",
            "        lret, rret = self._ie, self._ie",
            "        while l < r:",
            "            if l & 1:",
            "                lret = self._f(lret, self._dat[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                rret = self._f(self._dat[r], rret)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._f(lret, rret)",
            "",
            "",
            "class SegTree_EulerTour:",
            "    def __init__(self, n, G, node_cost=None):",
            "        self.n = n",
            "        self.G = G",
            "        self.root = None        # 根",
            "        self.Depth = [0] * n    # 頂点iの深さ",
            "        if node_cost:",
            "            self.Ncost = node_cost",
            "        else:",
            "            self.Ncost = [0] * n       # 頂点iの値",
            "        self.Ecost = [0] * n       # 辺iのコスト",
            "        self.TimeIn = [0] * n   # 頂点iに到達する時間",
            "        self.TimeOut = [0] * n  # 頂点iから抜け出す時間",
            "        self.ETNodes = []       # ツアー順i番目の頂点番号",
            "        self.ETDepth = []       # ツアー順i番目の深さ番号",
            "        self.ETNodesCost = []   # ツアー順i番目の頂点のコスト",
            "        self.ETEdgesCost = []   # ツアー順i番目の辺のコスト",
            "",
            "",
            "    def set_euler_tour(self, root=0):",
            "        self.root = root        # 根を設定して",
            "        pa = [-1] * self.n",
            "        stack = [~root, root]",
            "        ct = -1; de = -1",
            "        _ETedges = []",
            "        while stack:",
            "            v = stack.pop()",
            "            ct += 1",
            "            _ETedges.append(v)",
            "            if v >= 0:",
            "                self.TimeIn[v] = ct",
            "                de += 1",
            "                self.ETNodes.append(v)",
            "                self.ETDepth.append(de)",
            "                self.Depth[v] = de",
            "                p = pa[v]",
            "                for w, cost in self.G[v][::-1]:",
            "                    if w == p: continue",
            "                    self.Ecost[w] = cost",
            "                    pa[w] = v",
            "                    stack.extend([~w, w])",
            "                self.ETNodesCost.append(self.Ncost[v])",
            "                self.ETEdgesCost.append(self.Ecost[v])",
            "            else:",
            "                self.TimeOut[~v] = ct",
            "                de -= 1",
            "                if de < 0:",
            "                    self.ETDepth.append(self.n)",
            "                else:",
            "                    self.ETDepth.append(de)",
            "                self.ETNodes.append(pa[~v])",
            "                self.ETNodesCost.append(-self.Ncost[~v])",
            "                self.ETEdgesCost.append(-self.Ecost[~v])",
            "        self.sgt_depth = SegmentTree(self.ETDepth, lambda x, y: min(x, y), float('inf'))",
            "        self._ETedges = _ETedges",
            "        self.set_query()",
            "        self.parent = pa",
            "",
            "",
            "    def lca(self, a:int, b:int):",
            "        l = min(self.TimeIn[a], self.TimeIn[b])",
            "        r = max(self.TimeOut[a], self.TimeOut[b])",
            "        if l > r: l, r = r, l",
            "        mindepth = self.sgt_depth.query(l, r)",
            "        while r - l > 1:",
            "            mid = (l+r) // 2",
            "            if self.sgt_depth.query(l, mid) == mindepth:",
            "                r = mid",
            "            else:",
            "                l = mid",
            "        return self.ETNodes[l]",
            "",
            "    def __str__(self):",
            "        ret = \"\"",
            "        ret += \"[ NODE] \" + \" \".join(map(lambda x: str(x).rjust(4), range(self.n))) + \"\\n\"",
            "        ret += \"[   IN] \" + \" \".join(map(lambda x: str(x).rjust(4), self.TimeIn)) + \"\\n\"",
            "        ret += \"[  OUT] \" + \" \".join(map(lambda x: str(x).rjust(4), self.TimeOut)) + \"\\n\"",
            "        ret += \"[DEPTH] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Depth)) + \"\\n\"",
            "        ret += \"[NCOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Ncost)) + \"\\n\"",
            "        ret += \"[ECOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Ecost)) + \"\\n\" * 2",
            "        if not self.ETNodes: return ret",
            "        ret += \"[ TIME] \" + \" \".join(map(lambda x: str(x).rjust(4), range(len(self.ETNodes)))) + \"\\n\"",
            "        ret += \"[ NODE] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETNodes)) + \"\\n\"",
            "        ret += \"[DEPTH] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETDepth)) + \"\\n\"",
            "        ret += \"[NCOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETNodesCost)) + \"\\n\"",
            "        ret += \"[ECOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETEdgesCost)) + \"\\n\"",
            "        return ret",
            "",
            "    def root_edge_dist(self, u:int): return self.Depth[u]",
            "    def root_edge_cost(self, u:int): return self.sgt_edges.query(0, self.TimeIn[u] + 1)",
            "",
            "    def uv_edge_dist(self, u:int, v:int):",
            "        redist = self.root_edge_dist",
            "        lca = self.lca(u, v)",
            "        return redist(u) + redist(v) - 2 * redist(lca)",
            "",
            "    def uv_edge_cost(self, u:int, v:int):",
            "        recost = self.root_edge_cost",
            "        lca = self.lca(u, v)",
            "        return recost(u) + recost(v) - 2 * recost(lca)",
            "",
            "    def update_edge_cost(self, u, v, w):",
            "        if self.TimeIn[u] > self.TimeIn[v]: u, v = v, u",
            "        self.sgt_edges.update(self.TimeIn[v], w)",
            "        self.sgt_edges.update(self.TimeOut[v], -w)",
            "        self.ETEdgesCost[self.TimeIn[v]] = w",
            "        self.ETEdgesCost[self.TimeOut[v]] = -w",
            "",
            "    def add_edge_cost(self, u, v, w):",
            "        if self.TimeIn[u] > self.TimeIn[v]: u, v = v, u",
            "        self.sgt_edges.add(self.TimeIn[v], w)",
            "        self.sgt_edges.add(self.TimeOut[v], -w)",
            "        self.ETEdgesCost[self.TimeIn[v]] += w",
            "        self.ETEdgesCost[self.TimeOut[v]] -= w",
            "",
            "    def set_query(self):",
            "        ####################### 経路上の頂点ないしは辺の和",
            "        self.sgt_nodes = SegmentTree(self.ETNodesCost, lambda x, y: x + y, 0)",
            "        self.sgt_edges = SegmentTree(self.ETEdgesCost, lambda x, y: x + y, 0)",
            "",
            "",
            "###########################################",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "edges = []",
            "for _ in range(n-1):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            "    edges.append([a, b, w])",
            "",
            "seget = SegTree_EulerTour(n, G)",
            "seget.set_euler_tour(0)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    f, x, y = map(int, input().split())",
            "    if f == 1:",
            "        u, v, _ = edges[x-1]",
            "        seget.update_edge_cost(u, v, y)",
            "    else:",
            "        print(seget.uv_edge_cost(x-1, y-1))",
            "",
            ""
        ],
        "description": [
            "木の上の範囲クエリ RangeQuery"
        ],
        "scope": "python"
    },
    "DFS非再帰": {
        "prefix": [
            "Lib_G_DFS_非再帰"
        ],
        "body": [
            "",
            "# 深さ優先探索",
            "# 隣接リスト",
            "# 行きかけ、帰りがけ処理",
            "",
            "",
            "def dfs(G:list, st:int, goal=None):",
            "    # 深さ優先探索（行きがけTrue、帰りがけFalse）",
            "    n = len(G)",
            "    stack = []",
            "    seen = [False] * n",
            "    level = [-1] * n    # 階層",
            "    parent = [-1] * n   # 親node",
            "    dp = [-1] * n       # dp 適宜設定",
            "    # スタートの設定",
            "    stack.append((False, st))",
            "    stack.append((True, st))",
            "    seen[st] = True",
            "    level[st] = 0",
            "",
            "    while stack:",
            "        fg, cur = stack.pop()",
            "        if fg:",
            "        #行き掛け",
            "            seen[cur] = True",
            "            for nxt in G[cur]:",
            "                if seen[nxt]: continue",
            "                # 行きがけ処理",
            "                parent[nxt] = cur",
            "                level[nxt] = cur + 1",
            "                stack.append((False, nxt))",
            "                stack.append((True, nxt))",
            "        ############",
            "        else:",
            "        #帰り掛け",
            "            isok = True",
            "            # dp[cur] = 1                     # ex.部分木のノード数",
            "            for child in G[cur]:",
            "                if parent[cur] == child: continue",
            "                if dp[child] == 1:",
            "                    isok = False",
            "                # dp[cur] += dp[child]          # ex.部分木のノード数",
            "            dp[cur] = int(isok)",
            "            if cur == goal: return dp",
            "        ############",
            "    return dp",
            "",
            "##########################################",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    # a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "dp = dfs(G, 0)",
            "print(sum(dp))",
            ""
        ],
        "description": [
            "DFS非再帰"
        ],
        "scope": "python"
    },
    "Lib_G_枝刈り取る": {
        "prefix": [
            "Lib_G_cycle"
        ],
        "body": [
            "",
            "def cycle(n, G):",
            "    degree = [0] * n",
            "    for gi in G:",
            "        for i in gi:",
            "            degree[i] += 1",
            "",
            "    leaves = [i for i in range(n) if degree[i] == 1]",
            "    oncycle = set(range(n))",
            "    while leaves:",
            "        x = leaves.pop()",
            "        oncycle.remove(x)",
            "        for y in G[x]:",
            "            degree[y] -= 1",
            "            if degree[y] == 1:",
            "                leaves.append(y)",
            "    return oncycle",
            "",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "print(cycle(n, G))",
            ""
        ],
        "description": [
            "グラフの葉から枝を刈り取って、ループ部分のみ抽出する"
        ],
        "scope": "python"
    },
    "Lib_G_グラフ橋関節_lowlink": {
        "prefix": [
            "Lib_G_グラフ橋関節_lowlink"
        ],
        "body": [
            "#関節 https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_A",
            "#橋 https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_B",
            "",
            "class LowLink():",
            "    def __init__(self, G):",
            "        self.n = len(G)",
            "        self.ord = [None]*self.n    # DFS 行きがけ順",
            "        self.low = [None]*self.n    # lowlink",
            "        self.son = [[] for _ in range(self.n)]  # son[i] := 頂点iの子を格納したlist",
            "        self.back_edge = [[] for _ in range(self.n)] # back_edge[i] := 頂点iから出る後退辺の終点を格納したlist",
            "        self.tps = []                           # 頂点のトポロジカルソート",
            "        self.bridges = []",
            "",
            "    def build(self, root=0):",
            "        # DFSでord, son, tpsを求め、lowを初期化",
            "        time = 0 # DFSでの行きがけ順",
            "        stack = [(None, root)] # 直前にいた頂点, 今いる頂点",
            "        while stack:",
            "            pre, now = stack.pop()",
            "            if self.ord[now] is not None: # 後退辺を通ってきた場合",
            "                if self.ord[pre] < self.ord[now]: continue # 後退辺を根側から進んでいた場合は無視",
            "                self.low[pre] = min(self.low[pre], self.ord[now]) # low[pre]をord[now]でchmin",
            "                self.back_edge[pre].append(now)",
            "                continue",
            "            if pre is not None: self.son[pre].append(now)   # 親子関係を記録",
            "            self.tps.append(now)",
            "            self.ord[now] = time",
            "            self.low[now] = self.ord[now] # low[now]をord[now]で初期化",
            "            time += 1",
            "            for next in G[now]:",
            "                if next == pre: continue",
            "                stack.append((now, next))",
            "        for u in reversed(self.tps):# トポソ逆順にlowを求める",
            "            for v in self.son[u]:",
            "                self.low[u] = min(self.low[u], self.low[v])",
            "            for v in self.son[u]:",
            "                if self.low[v] > self.ord[u]:",
            "                    self.bridges.append((min(u, v), max(u, v)))",
            "",
            "    def two_edge_connected_component(self):",
            "        # 二重辺連結成分分解",
            "        tecc = []                   # tecc[i] := 連結成分iの頂点グループ",
            "        tecc_idx = [None]*self.n    # tecc_idx[i] := 頂点iが属する連結成分ID",
            "        tecc_tree = []              # 連結成分を頂点、橋を辺としたグラフ(木)の隣接リスト",
            "",
            "        sub_roots = [(None, 0)]     # 橋を見つけるごとに、その先は部分木として別にDFSしなおす。",
            "        idx = 0     # 今いる頂点の連結成分の番号",
            "        while sub_roots:",
            "            stack = [sub_roots.pop()] # 部分木の根からDFS",
            "            tecc.append([]) # 今いる頂点の連結成分を格納するlistを追加",
            "            tecc_tree.append([]) # 今いる頂点の連結成分の隣接先を格納するlistを追加",
            "            while stack:",
            "                pre, now = stack.pop()",
            "                tecc[idx].append(now)   # 今いる頂点を連結成分idxに追加",
            "                tecc_idx[now] = idx     # 今いる頂点の連結成分の番号idxを記録",
            "                if pre is not None and idx != tecc_idx[pre]: # 直前に橋を通ってきていたら",
            "                    tecc_tree[idx].append(tecc_idx[pre]) # その橋で繋がれた2つの連結成分を辺で結ぶ",
            "                    tecc_tree[tecc_idx[pre]].append(idx)",
            "                for next in self.son[now]:",
            "                    if self.low[next] > self.ord[now]: # 橋なら",
            "                        sub_roots.append((now, next)) # その先は別の連結成分",
            "                    else:",
            "                        stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "            idx += 1",
            "        return tecc, tecc_idx, tecc_tree",
            "",
            "    def biconnected_component(self):",
            "        # 二重頂点連結成分分解",
            "        bce = [] # bce[i] := 連結成分iに属する辺を格納したlist",
            "        bcv = [] # bcv[i] := 連結成分iに属する頂点を格納したlist",
            "        is_ap = [False]*self.n # is_ap[i] := 頂点iは関節点であるか(True/False)",
            "        sub_roots = [(None, 0)] #「ある子に対する関節点」を見つけるごとに、その子以降は部分木として別にDFSしなおす。",
            "        idx = 0 # 今いる頂点の連結成分の番号",
            "        while sub_roots:",
            "            stack = [sub_roots.pop()] # 部分木の根からDFS",
            "            bce.append([]) # 今いる頂点の連結成分に含まれる辺を格納するlistを追加",
            "            bcv.append([]) # 今いる頂点の連結成分に含まれる頂点を格納するlistを追加",
            "            if stack[0][0] is not None: # 直前に通った頂点(関節点)が存在するなら",
            "                bcv[idx].append(stack[0][0]) # それを連結成分idxに追加",
            "            while stack:",
            "                pre, now = stack.pop()",
            "                if pre is not None: # 直前に通った辺が存在するなら",
            "                    bce[idx].append((pre, now)) # 通ってきた辺を連結成分idxに追加",
            "                bcv[idx].append(now) # 今いる頂点を連結成分idxに追加",
            "                if now == 0: # 今いる頂点nowが根で",
            "                    if len(self.son[now]) >= 2: # 関節点であるなら",
            "                        for next in self.son[now]:",
            "                            is_ap[now] = True # 関節点であことを記録",
            "                            sub_roots.append((now, next)) # その先は別の連結成分",
            "                        bce.pop() # 「根の関節点のみ」の連結成分は存在しないが追加してしまっているので、例外的に削除する",
            "                        bcv.pop()",
            "                        idx -= 1",
            "                    else: # 関節点でないなら",
            "                        for next in self.son[now]:",
            "                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "                else: # 根でなく",
            "                    for next in self.son[now]:",
            "                        if self.low[next] >= self.ord[now]: # 子nextに対して関節点なら",
            "                            is_ap[now] = True # 関節点であることを記録",
            "                            sub_roots.append((now, next)) # その先は別の連結成分",
            "                        else: # 関節点でないなら",
            "                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "                if now == 0 and len(self.son[now]) <= 1:",
            "                    for back in self.back_edge[now]: # 今いる頂点から出る後退辺は同じ連結成分なので",
            "                        bce[idx].append((now, back)) # 連結成分idxに追加",
            "            idx += 1",
            "        return bce, bcv, is_ap",
            "",
            "    # block-cut treeを構築",
            "    def block_cut_tree(self):",
            "        bce, bcv, is_ap = self.biconnected_component() # 二重頂点連結成分分解",
            "        num_ap = sum(is_ap) # 関節点の個数",
            "        bc = [[] for _ in range(num_ap+len(bcv))]",
            "        # bc[i] := block-cut tree上の頂点iに対応する頂点を格納したlist",
            "        # [0:num_ap)は関節点に対応する頂点で、その関節点のみがlistに含まれる",
            "        # [num_ap:len(bc))は連結成分に対応する頂点で、その連結成分から関節点を除いたものがlistに含まれる",
            "        # block-cut tree上の頂点iが関節点に対応している ⇔ i < num_ap",
            "        bc_idx = [None]*self.n",
            "        # bc_idx[i] := (元グラフの)頂点iが属するblock-cut tree上の頂点の番号(bc, bc_treeのindexに対応)",
            "        # 関節点でない頂点iについて、対応するbce, bcvのindexが知りたい場合、bc_idx[i]-num_apで取得可能。",
            "        bc_tree = [[] for _ in range(num_ap+len(bcv))] # bc_tree[i] := block-cut tree上の頂点iの隣接頂点を格納したlist",
            "        idx = 0 # 今見ているblock-cut tree上の頂点番号",
            "        for v in range(self.n): # (元グラフの)各頂点vについて",
            "            if is_ap[v]: # 関節点なら",
            "                bc[idx].append(v) # block-cut tree上の頂点idxにvを対応させる",
            "                bc_idx[v] = idx",
            "                idx += 1",
            "        for bcv_i in bcv: # 各連結成分の",
            "            for v in bcv_i: # 各頂点vについて",
            "                if is_ap[v]: # 関節点なら",
            "                    bc_tree[idx].append(bc_idx[v]) # block-cut tree上の頂点idxと関節点vに対応した頂点を辺で結ぶ",
            "                    bc_tree[bc_idx[v]].append(idx)",
            "                else: # そうでないなら",
            "                    bc[idx].append(v) # block-cut tree上の頂点idxに対応した頂点集合に頂点vを追加",
            "                    bc_idx[v] = idx",
            "            idx += 1",
            "        return bc, bc_idx, bc_tree, num_ap, bce, bcv, is_ap",
            "",
            "#####################################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "x = LowLink(G)",
            "x.build()",
            "for i, xi in enumerate(x.biconnected_component()[-1]):",
            "    if xi: print(i)",
            "",
            "# https://kntychance.hatenablog.jp/entry/2022/09/16/161858",
            "# n = 10",
            "# m = 12",
            "# edge = [(0,1), (1,2), (2,3), (2,4), (2,5), (1,5), (1,6), (1,8), (6,7), (6,8), (0,9), (8,9)]",
            "# G = [[] for _ in range(n)]",
            "# for _ in range(m):",
            "#     # a, b = map(int, input().split())",
            "#     # a -= 1; b -= 1",
            "#     G[a].append(b)",
            "#     G[b].append(a)",
            "# for gi in G:",
            "#     gi.sort(reverse=True)",
            "",
            "# x = LowLink(G)",
            "# x.build()",
            "# print(x.ord)",
            "# print(x.son)",
            "# print(x.low)",
            "#print(x.bridges)",
            "#print(x.two_edge_connected_component())",
            "# print(x.biconnected_component())",
            ""
        ],
        "description": [
            "グラフの橋・関節をO(n)で検出"
        ],
        "scope": "python"
    },
    "ユニオンファインド": {
        "prefix": [
            "Lib_G_unionfind"
        ],
        "body": [
            "",
            "class UnionFind:",
            "    \"\"\"木の深さが小さい方を親にする\"\"\"",
            "    def __init__(self, n):",
            "        self.n = n                              # 要素数",
            "        self.parents = [i for i in range(n)]    # 親",
            "        self.ranks = [0] * n                    # 木の深さ",
            "        self.sizes = [1] * n                    # グループの要素数",
            "        self.groups = dict()                    # グループ key:parent, value:listofmember",
            "",
            "    def find(self, x):",
            "        if self.parents[x] == x: return x",
            "        self.parents[x] = p = self.find(self.parents[x])",
            "        return p",
            "",
            "    def _choose_parent(self, x, y):",
            "        \"\"\"木の深さが大きい方を親とする\"\"\"",
            "        if self.ranks[x] > self.ranks[y]:",
            "            x, y = y, x",
            "        if self.ranks[x] == self.ranks[y]:",
            "            self.ranks[y] += 1",
            "        return x, y",
            "",
            "    def unite(self, x, y):",
            "        x, y = self.find(x), self.find(y)",
            "        if x == y: return",
            "        x, y = self._choose_parent(x, y)",
            "        self.parents[x] = y",
            "        self.sizes[y] += self.sizes[x]",
            "",
            "    def is_same(self, x, y) -> bool:",
            "        return self.find(x) == self.find(y)",
            "",
            "    def size(self, x):",
            "        \"\"\"xのグループの要素数\"\"\"",
            "        return self.sizes[self.find(x)]",
            "",
            "    def get_groups(self):",
            "        \"\"\"親のリスト取得",
            "            親ごとのグループのメンバー一覧取得",
            "        \"\"\"",
            "        self.groups = dict()",
            "        for i in range(self.n):",
            "            p = self.find(i)",
            "            if p not in self.groups:",
            "                self.groups[p] = []",
            "            self.groups[p].append(i)",
            "        return",
            "",
            "    def __str__(self):",
            "        self.get_groups()",
            "        print(f'group_count = {len(self.groups)}')",
            "        return ' '.join([f'{p}:{v}' for p, v in sorted(self.groups.items())])",
            "",
            "class UnionFindMax(UnionFind):",
            "    def _choose_parent(self, x, y):",
            "        \"\"\"ノード番号が大きい方を親にする\"\"\"",
            "        if x > y:",
            "            x, y = y, x",
            "        return x, y",
            "",
            "class UnionFindMin(UnionFind):",
            "    def _choose_parent(self, x, y):",
            "        \"\"\"ノード番号が小さい方を親にする\"\"\"",
            "        if x < y:",
            "            x, y = y, x",
            "        return x, y",
            "",
            "",
            "################",
            "",
            "n, q = map(int, input().split())",
            "uf = UnionFind(n)",
            "for _ in range(q):",
            "    p, a, b = map(int,input().split())",
            "    # a -= 1; b -= 1",
            "    if p == 0:",
            "        uf.unite(a, b)",
            "    else:",
            "        if uf.is_same(a, b):",
            "            print('Yes')",
            "        else:",
            "            print('No')",
            "",
            "# https://atcoder.jp/contests/atc001/tasks/unionfind_a",
            ""
        ],
        "description": [
            "ユニオンファインド"
        ],
        "scope": "python"
    },
    "ユニオンファインド部分永続": {
        "prefix": [
            "Lib_G_unionfindPP"
        ],
        "body": [
            "class UnionFindPP:",
            "    def __init__(self, n):",
            "        self.INF = 1e20",
            "        self.now = 0",
            "        self.n = 0",
            "        self.parents = [-1 for i in range(n)]",
            "        self.time = [self.INF for i in range(n)]",
            "        self.num = [[(0,1)] for i in range(n)]",
            "",
            "    def find(self,t,x):",
            "        '''",
            "        version:tにおけるxの根を見つける",
            "        t (any) : version",
            "        x (int) : 要素",
            "        return : int : 根",
            "        '''",
            "        while self.time[x] <= t:",
            "            x = self.parents[x]",
            "        return x",
            "",
            "    def unite(self,x,y):",
            "        '''",
            "        x,yをつなげる",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        '''",
            "        self.now += 1",
            "        x = self.find(self.now,x)",
            "        y = self.find(self.now,y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parents[x] > self.parents[y]:",
            "            x,y = y,x",
            "",
            "        self.parents[x] += self.parents[y]",
            "        self.parents[y] = x",
            "        self.time[y] = self.now",
            "        self.num[x].append((self.now,-self.parents[x]))",
            "",
            "    def is_same(self,t,x,y):",
            "        '''",
            "        version:tにおけるx,yが同じかどうかO(logN)",
            "        t (any) : version",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        return : bool : 同じかどうか",
            "        '''",
            "        return self.find(t,x) == self.find(t,y)",
            "",
            "    def size(self,t,x):",
            "        '''",
            "        version:tにおける要素xが含まれる集合の大きさ",
            "        t (any) : version",
            "        x (int) : 要素",
            "        return : int :集合の大きさ",
            "        '''",
            "        x = self.find(t,x)",
            "        numx = self.num[x]",
            "        ok = 0",
            "        ng = len(numx)",
            "        while (ng-ok > 1):",
            "            mid = (ok+ng)>>1",
            "            if numx[mid][0] <= t:",
            "                ok = mid",
            "            else:",
            "                ng = mid",
            "",
            "        return numx[ok][1]",
            "",
            "    def time_join(self, x, y):",
            "        '''",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        return : int :同一のグループとなった時",
            "        '''",
            "        upper = self.now",
            "        if not self.is_same(upper, x, y): return -1",
            "        lower = 0",
            "        while upper - lower > 1:",
            "            mid = (upper+lower)//2",
            "            if self.is_same(mid, x, y):",
            "                upper = mid",
            "            else:",
            "                lower = mid",
            "        return upper",
            "",
            "",
            "n, m = map(int, input().split())",
            "uf = UnionFindPP(n)",
            "",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    uf.unite(a, b)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    print(uf.time_join(a, b))",
            "# https://atcoder.jp/contests/code-thanks-festival-2017/tasks/code_thanks_festival_2017_h",
            ""
        ],
        "description": [
            "ユニオンファインド部分永続"
        ],
        "scope": "python"
    },
    "ユニオンファインド重み付き": {
        "prefix": [
            "Lib_G_unionfind_weighted"
        ],
        "body": [
            "",
            "class UnionFindWeighted:",
            "    def __init__(self, n):                      # 初期化",
            "        self.INF = 1e18",
            "        self.n = n                              # 要素数",
            "        self.parents = [i for i in range(n)]    # 親",
            "        self.ranks = [0] * n                    # 木の深さ",
            "        self.sizes = [1] * n                    # グループの要素数",
            "        self.weights = [0] * n                  # 親との重み",
            "        self.isvalid = [True] * n               # ポテンシャルがプラスの閉路あり",
            "        self.leaders = None                     # リーダー",
            "        self.groups = None                      # グループ",
            "",
            "    def find(self, x):",
            "        if self.parents[x] == x: return x",
            "        p = self.find(self.parents[x])",
            "        self.weights[x] += self.weights[self.parents[x]]",
            "        self.parents[x] = p",
            "        return p",
            "",
            "    def unite(self, x, y, w):",
            "        rx = self.find(x)",
            "        ry = self.find(y)",
            "        if rx == ry:",
            "            if self.diff(x, y) != w:",
            "                self.isvalid[rx] = False",
            "                return \"invalid\"    # 整合性がない情報がある",
            "            else:",
            "                return \"pass\"       # 整合性がある",
            "        # a[x]->a[y]  の差はw  # a[y] = a[x] + w",
            "        wx = self.weight(x)",
            "        wy = self.weight(y)",
            "        if self.ranks[rx] > self.ranks[ry]:",
            "            rx , ry = ry, rx    #ryを親にする",
            "            wx , wy = wy, wx",
            "            w *= -1",
            "        elif self.ranks[rx]==self.ranks[ry]:",
            "            self.ranks[ry] += 1",
            "        self.parents[rx] = ry",
            "        self.sizes[ry] += self.sizes[rx]",
            "        self.weights[rx] = wy - wx - w",
            "        self.isvalid[ry] &= self.isvalid[rx]",
            "        return \"unite\"",
            "",
            "    def is_same(self, x, y) -> bool:",
            "        return self.find(x) == self.find(y)",
            "",
            "    def get_size(self, x):",
            "        \"\"\"xのグループの要素数\"\"\"",
            "        return self.sizes[self.find(x)]",
            "",
            "    def get_groups(self):",
            "        \"\"\"親のリスト取得",
            "            親ごとのグループのメンバー一覧取得",
            "        \"\"\"",
            "        leader_buf = [self.find(i) for i in range(self.n)]",
            "        self.leaders = []",
            "        result = [[] for _ in range(self.n)]",
            "        for i in range(self.n):",
            "            if leader_buf[i] == i:",
            "                self.leaders.append(i)",
            "            result[leader_buf[i]].append(i)",
            "        self.gropus = result",
            "        return result",
            "",
            "    def weight(self, x):",
            "        \"\"\"重み\"\"\"",
            "        self.find(x)",
            "        return self.weights[x]",
            "",
            "    def diff(self, x, y):",
            "        \"\"\"重みの差\"\"\"",
            "        rx = self.find(x)",
            "        ry = self.find(y)",
            "        if rx != ry: return self.INF",
            "        return self.weight(y) - self.weight(x)",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {self.members(r)}' for r in self.leaders)",
            "",
            "################",
            "",
            "n, m = map(int, input().split())",
            "uf = UnionFindWeighted(n)",
            "for _ in range(m):",
            "    a, b, w = map(int,input().split())",
            "    a -= 1; b -= 1",
            "    uf.unite(a, b, w)",
            ""
        ],
        "description": [
            "ユニオンファインド重み付き"
        ],
        "scope": "python"
    },
    "Graph最遠パス": {
        "prefix": [
            "Lib_G_最短パス"
        ],
        "body": [
            "",
            "# root から始めて一番遠いところにあるノードを見つける",
            "from collections import deque",
            "def bfs(n, G, root=0, cost=1):",
            "    _depth = [None] * n",
            "    q = deque()",
            "    q.append(root)",
            "    _depth[root] = 0",
            "    _parent = [-1] * n",
            "    farest_dist = -1",
            "    while q:",
            "        cur = q.popleft()",
            "        dep = _depth[cur]",
            "        for nxt in G[cur]:",
            "            if type(nxt) != int: nxt, cost = nxt",
            "            if _depth[nxt] != None: continue",
            "            newdep = dep + cost",
            "            q.append(nxt)",
            "            _parent[nxt] = cur",
            "            _depth[nxt] = newdep",
            "            if newdep > farest_dist:",
            "                farest_dist = newdep",
            "                farest_node = nxt",
            "    return farest_node, farest_dist, _depth",
            "",
            "",
            "##############################",
            "",
            "",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            "",
            "",
            ""
        ],
        "description": [
            "Graph最遠パス"
        ],
        "scope": "python"
    },
    "包除原理": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "####subtitle######": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "n(A or B or C) = n(A) + n(B) + n(C)": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "                 -n(A&B) -n(B&C) -n(C&A)": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "                 +n(A&B&C)": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "行列演算2": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "escripiton#": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "行列回転": {
        "prefix": [
            "Lib_M_matrix-回転と反転"
        ],
        "body": [
            "class Matrix():",
            "    def __init__(self, n, v=None):",
            "        self.n = n",
            "        self.state = [0, 0]",
            "        self.matrix_origin = [[v] * n for _ in range(n)]",
            "",
            "    def rotate(self, t):",
            "        self.state[0] = (self.state[0] + t) % 4",
            "",
            "",
            "    def reverse_lr(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 1:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def reverse_ud(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 0:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def get_original_positon(self, x, y):",
            "        n = self.n",
            "        if self.state == [0, 0]: return x, y",
            "        if self.state == [1, 0]: return n-1-y, x",
            "        if self.state == [2, 0]: return n-1-x, n-1-y",
            "        if self.state == [3, 0]: return y, n-1-x",
            "",
            "        if self.state == [0, 1]: return x, n-1-y",
            "        if self.state == [1, 1]: return n-1-y, n-1-x",
            "        if self.state == [2, 1]: return n-1-x, y",
            "        if self.state == [3, 1]: return y, x",
            "        else:",
            "            print(self.state)",
            "",
            "    def set_value(self, x, y, v):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        self.matrix_origin[ox][oy] = v",
            "",
            "    def get_value(self, x, y):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        return self.matrix_origin[ox][oy]",
            "",
            "n, q = map(int, input().split())",
            "mx = Matrix(n, 0)",
            "",
            "for _ in range(q):",
            "    que = list(input().split())",
            "    if que[0] == '1':",
            "        x = int1(que[1])",
            "        y = int1(que[2])",
            "        mx.set_value(x, y, 1 - mx.get_value(x, y))",
            "    if que[0] == '2':",
            "        if que[1] == 'A':",
            "            mx.rotate(1)",
            "        else:",
            "            mx.rotate(3)",
            "    if que[0] == '3':",
            "        if que[1] == 'A':",
            "            mx.reverse_ud()",
            "        else:",
            "            mx.reverse_lr()",
            "",
            "for i in range(n):",
            "    ret = []",
            "    for j in range(n):",
            "        ret.append(mx.get_value(i, j))",
            "    print(''.join(map(str, ret)))",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "行列演算": {
        "prefix": [
            "Lib_M_行列演算_matrix"
        ],
        "body": [
            "",
            "def matprod(ma, mb, mod = 10**9+7):",
            "    h_a = len(ma)   # n",
            "    w_a = len(ma[0])    # m",
            "    h_b = len(mb)   # m",
            "    w_b = len(mb[0])    # k",
            "    assert(w_a == h_b)",
            "    assert(h_a*w_a*h_b*w_b)",
            "",
            "    tmb = [list(x) for x in zip(*mb)]",
            "    ret = [[0] * w_b for _ in range(h_a)]",
            "    for _i, mai in enumerate(ma):",
            "        reti = ret[_i]",
            "        for _j, mbk in enumerate(tmb):",
            "            reti[_j] = sum(a*b%mod for a, b in zip(mai, mbk)) % mod",
            "    return ret",
            "",
            "",
            "def matpow(ma, k, mod = 10**9+7):",
            "    n = len(ma)",
            "    ret = [[0]*n for _ in range(n)]",
            "    for i in range(n):",
            "        ret[i][i] = 1",
            "    for _ in range(k):",
            "        if k & 1:",
            "            ret = matprod(ret, ma, mod)",
            "        ma = matprod(ma, ma, mod)",
            "        k >>= 1",
            "        if k == 0: break",
            "    return ret",
            "",
            "mod = 998244353",
            "n, m, k = map(int, input().split())",
            "ma = [list(map(int, input().split())) for _ in range(n)]",
            "mb = [list(map(int, input().split())) for _ in range(m)]",
            "",
            "",
            "",
            "for r in matprod(ma, mb, mod):",
            "    print(*r)",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "転置行列": {
        "prefix": [
            "transpose_matrix"
        ],
        "body": [
            "def trans(A):",
            "    return [list(x) for x in zip(*A)]"
        ],
        "description": [
            "転置行列"
        ],
        "scope": "python"
    },
    "行列90度回転": {
        "prefix": [
            "Lib_M_rotate_matrix"
        ],
        "body": [
            "def rotate(A, reverse = False):",
            "    if reverse:",
            "        return [list(x) for x in zip(*A)][::-1]",
            "    else:",
            "        return [list(x) for x in zip(*A[::-1])]"
        ],
        "description": [
            "行列90度回転"
        ],
        "scope": "python"
    },
    "F2(2進数)での上三角行列生成": {
        "prefix": [
            "Lib_M_上三角行列"
        ],
        "body": [
            "def gauss_jordan(ma):",
            "    n, m = len(ma), len(ma[0])",
            "    rank = 0",
            "    for col in range(m):",
            "        if rank>=n: break",
            "        if ma[rank][col] == 0:",
            "            for row in range(rank+1, n):",
            "                if ma[row][col]:",
            "                    ma[rank], ma[row] = ma[row], ma[rank]",
            "                    break",
            "        if ma[rank][col] == 1:",
            "            for row in range(rank+1, n):",
            "                if ma[row][col]:",
            "                    for _col in range(col, m):",
            "                        ma[row][_col] ^= ma[rank][_col]",
            "            rank += 1",
            "    return ma, rank",
            ""
        ],
        "description": [
            "F2(2進数)での上三角行列生成"
        ],
        "scope": "python"
    },
    "F2(2進数)でのA・x = b となるxを見つける": {
        "prefix": [
            "Lib_M_線形方程式"
        ],
        "body": [
            "def solve_linear_equation(A, b):",
            "    \"\"\"A・x = b となるxを見つける\"\"\"",
            "    h, w = len(A), len(A[0])",
            "    \"\"\"extend\"\"\"",
            "    _A = []",
            "    for Ai, bi in zip(A, b):",
            "        _A.append(Ai + [bi])",
            "    rank = 0",
            "    for col in range(w):",
            "        for row in range(rank, h):",
            "            if _A[row][col]:",
            "                _A[row], _A[rank] = _A[rank], _A[row]",
            "                break",
            "        else: continue",
            "        for row in range(h):",
            "            if row != rank and _A[row][col]:",
            "                for _col in range(w + 1):",
            "                    _A[row][_col] ^= _A[rank][_col]",
            "        rank += 1",
            "    # for ai in A: print(ai)",
            "    # print(\"---\")",
            "    # for ai in _A: print(ai)",
            "    # print(rank)",
            "    return _A, rank",
            ""
        ],
        "description": [
            "F2(2進数)でのA・x = b となるxを見つける"
        ],
        "scope": "python"
    },
    "フロアサム": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "一次直線(y=ax+b (0<=x<n の下にあるmの倍数の整数点の個数)": {
        "prefix": [
            "Lib_N_floor_sum"
        ],
        "body": [
            "",
            "from atcoder.math import floor_sum",
            "",
            "for _ in range(int(input())):",
            "    n, m, a, b = map(int, input().split())",
            "    print(floor_sum(n, m, a, b))",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "nCr": {
        "prefix": [
            "Lib_N_nCr剰余"
        ],
        "body": [
            "",
            "",
            "#####################################",
            "# nCr % 10**9+7",
            "# http://zakii.la.coocan.jp/enumeration/10_balls_boxes.htm",
            "#####################################",
            "class Combination:",
            "    def __init__(self, maxn:int=10**6, mod:int=1000000007) -> None:",
            "        self.mod = mod",
            "        self.maxn = maxn",
            "        _maxn = maxn + 1",
            "        fac, facinv, inv = [1]*_maxn, [1]*_maxn, [1]*_maxn",
            "        for i in range(2, _maxn):",
            "            fac[i] = fac[i-1] * i % mod",
            "            inv[i] = _inv = (mod - inv[mod % i] * (mod // i) % mod) % mod",
            "            facinv[i] = facinv[i-1] * _inv % mod",
            "        self.fac = fac; self.facinv = facinv",
            "",
            "    def nCr(self, n, r):",
            "        \"\"\"nCr",
            "        n個のものからr個選ぶ",
            "        \"\"\"",
            "        if ( r<0 or r>n ):",
            "            return 0",
            "        r = min(r, n-r)",
            "        return self.fac[n] * (self.facinv[r] * self.facinv[n-r] % self.mod) % self.mod",
            "",
            "cmb = Combination",
            "ret = cmb.nCr(4, 2)",
            "",
            "",
            "#####################################",
            "# nは大きいが固定で,rは小さい場合",
            "# nCr % 10**9+7  n～10^9 r～10^5",
            "# nは大きいが固定で,rは小さい場合",
            "#####################################",
            "class CombinationSmallR:",
            "    def __init__(self, n:int=10**9, mod:int=1000000007) -> None:",
            "        self.n = n",
            "        self.max_r = 1",
            "        self.mod = mod",
            "        self.nCrseq = [1, n%mod]",
            "",
            "",
            "    def __preprocessing(self, max_r:int) -> None:",
            "        if max_r <= self.max_r: return",
            "        mod, seq = self.mod, self.nCrseq",
            "        seq += [0] * (max_r - self.max_r)",
            "        for i in range(self.max_r + 1, max_r + 1):",
            "            seq[i] = (seq[i-1] * (self.n-i+1) * pow(i,mod-2,mod)) % mod",
            "        self.max_r = max_r",
            "",
            "",
            "    def nCr(self, r:int) -> int:",
            "        self.__preprocessing(r)",
            "        return self.nCrseq[r]",
            "",
            "cmb = CombinationSmallR(10)",
            "print(cmb.nCr(4))",
            "",
            "",
            "",
            "#####################################",
            "# nCr % 3",
            "#####################################",
            "class CombinationMod3:",
            "    def __init__(self, n=10**6):",
            "        self.bf, self.bg = [0] * n, [0] * n",
            "        self.bg[0] = 1",
            "",
            "        for i in range(1, n):",
            "            pos = i",
            "            while pos % 3 == 0:",
            "                pos //= 3; self.bf[i] += 1",
            "            self.bg[i] = pos % 3",
            "",
            "        for i in range(1, n):",
            "            self.bf[i] += self.bf[i-1]",
            "            self.bg[i] = self.bg[i] * self.bg[i-1] % 3",
            "        self.MaxN = n",
            "",
            "    def nCr(self, n, r):",
            "        bf = self.bf",
            "        if bf[n] != bf[r] + bf[n-r]: return 0",
            "        bgn = self.bg[n]",
            "        bgrnr = self.bg[r] * self.bg[n-r]",
            "        if bgn == 1 and bgrnr == 1: return 1",
            "        if bgn == 1 and bgrnr == 4: return 1",
            "        if bgn == 2 and bgrnr == 2: return 1",
            "        if bgn == 1 and bgrnr == 2: return 2",
            "        if bgn == 2 and bgrnr == 1: return 2",
            "        if bgn == 2 and bgrnr == 4: return 2",
            "        return -1",
            "",
            "",
            "c = CombinationMod3(10**6)",
            "print(c.nCr(5,1))   #5mod3->2",
            "print(c.nCr(5,2))   #10mod3->1",
            "print(c.nCr(6,2))   #15mod3->0",
            "print(c.nCr(6,3))   #20mod3->2",
            ""
        ],
        "description": [
            "nCr剰余"
        ],
        "scope": "python"
    },
    "Lib_permutation": {
        "prefix": [
            "Lib_permutation_順列"
        ],
        "body": [
            "",
            "class permutation:",
            "    def __init__(self, L):",
            "        self.n = len(L)",
            "        self.L = L",
            "        self.LS = sorted(L[:])",
            "        self.map = {li: i for i, li in enumerate(self.LS)}",
            "        nn = self.n + 1",
            "        fa = [1] * (nn + 1)",
            "        for i in range(nn):",
            "            fa[i+1] = fa[i] * (i+1)",
            "        self.fa = fa",
            "        self.convL = self._convL(self.L)",
            "        self.facn = self.fa[self.n]",
            "        self.k = self.id_of_permutation(self.L)",
            "",
            "    def _convL(self, L):",
            "        return [self.map[li] for li in L]",
            "",
            "    def _restoreP(self, P):",
            "        return [self.LS[i] for i in P]",
            "",
            "    def _kth_permutation(self, k):",
            "        # zero-indexed here",
            "        n = self.n",
            "        S = [i for i in range(n)]",
            "        L = []",
            "        for i in range(n):",
            "            a = self.fa[n-1-i]",
            "            j = k // a",
            "            k %= a",
            "            L.append(S[j])",
            "            S = S[:j] + S[j+1:]",
            "        return L",
            "",
            "    def _id_of_permutation(self, P):",
            "        # zero-indexed here",
            "        ret = 0",
            "        while len(P) > 1:",
            "            a = len([l for l in P if l < P[0]])",
            "            ret += a * self.fa[len(P) - 1]",
            "            P = P[1:]",
            "        return ret",
            "",
            "    def id_of_permutation(self, L=None)->int:",
            "        \"\"\"",
            "        return: 順列の辞書順",
            "        \"\"\"",
            "        if L:",
            "            P = self._convL(L)",
            "            return self._id_of_permutation(P)",
            "        else: return self.k",
            "",
            "    def kth_permutation(self, k)->list:",
            "        \"\"\"",
            "        return: k番目の順列",
            "        \"\"\"",
            "        P = self._kth_permutation(k)",
            "        return self._restoreP(P)",
            "",
            "    def prev(self, L=None):",
            "        \"\"\"",
            "        return: 初期順列または入力順列のひとつ前",
            "        \"\"\"",
            "        if L:",
            "            k = self.id_of_permutation(L)",
            "        else:",
            "            k = self.k",
            "        if k == 0: return None",
            "        return self.kth_permutation(self.k - 1)",
            "",
            "    def next(self, L=None):",
            "        if L:",
            "            k = self.id_of_permutation(L)",
            "        else:",
            "            k = self.k",
            "        if k + 1 == self.facn: return None",
            "        return self.kth_permutation(k + 1)",
            "",
            "##################################",
            "N = int(input())",
            "P = [int(a) for a in input().split()]",
            "mut = permutation(P)",
            "print(*mut.prev())",
            ""
        ],
        "description": [
            "順列のライブラリ"
        ],
        "scope": "python"
    },
    "ユークリッド互除法": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "gcd, extgcd": {
        "prefix": [
            "Lib_N_gcd_ユークリッド互除法"
        ],
        "body": [
            "",
            "INF = 1 << 64",
            "import math",
            "",
            "# math.gcd(a, b)",
            "# math.lcm(a, b)",
            "",
            "def extgcd(a, b):",
            "    \"\"\"",
            "    d = gcd(a, b)",
            "    ax + by = d となるx, y, dを出力",
            "    \"\"\"",
            "    if b == 0:",
            "        return (1, 0, a)",
            "    q, r = a // b, a % b",
            "    x, y, d = extgcd(b, r)",
            "    s, t = y, x - q * y",
            "    return s, t, d",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "中国式剰余定理": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "mod ai = xi となるような整数の最小値を求める": {
        "prefix": [
            "Lib_N_chinese_CRT_中国式剰余定理"
        ],
        "body": [
            "",
            "INF = 1 << 64",
            "",
            "def gcd(a, b):",
            "    \"\"\"",
            "    return gcd(a,b)",
            "    \"\"\"",
            "    if b == 0: return a",
            "    return gcd(b, a%b)",
            "",
            "",
            "def extgcd(a, b):",
            "    \"\"\"",
            "    return (x,y,d) ax + by = gcd(a,b)",
            "    \"\"\"",
            "    if b == 0:",
            "        return (1, 0, a)",
            "    q, r = a // b, a % b",
            "    x, y, d = extgcd(b, r)",
            "    s, t = y, x - q * y",
            "    return s, t, d",
            "",
            "",
            "def CRT(rem_list, mod_list, MOD=INF):",
            "    \"\"\"",
            "    constraint:",
            "        gcd(pi,pj) = 1 if i!= j",
            "",
            "    return pair of (y,M) :x == y (modulo M)",
            "    which satisfies x = rem_list[i] (mod mod_list[i])",
            "    \"\"\"",
            "    K = len(mod_list)",
            "    assert len(rem_list) == len(mod_list)",
            "    X = [0] * K",
            "    res = 0",
            "    fact = 1",
            "    for i in range(K):",
            "        X[i] = rem_list[i]",
            "        for j in range(i):",
            "            X[i] = extgcd(mod_list[j], mod_list[i])[0] * (X[i] - X[j])",
            "            X[i] %= mod_list[i]",
            "        res = (res + X[i] * fact) % MOD",
            "        fact = (fact * mod_list[i]) % MOD",
            "    return (res, fact)",
            "",
            "",
            "def pair_CRT(rem_pair, mod_pair):",
            "    assert len(rem_pair) == len(mod_pair) == 2",
            "    d = gcd(mod_pair[0], mod_pair[1])",
            "    if (rem_pair[0] - rem_pair[1]) % d != 0:",
            "        return INF, INF",
            "    s = (mod_pair[1] - mod_pair[0])//d",
            "    M = mod_pair[0]*mod_pair[1]//d",
            "    x = (rem_pair[0] + s*mod_pair[0] *",
            "        extgcd(mod_pair[0]//d, mod_pair[1]//d)[0]) % M",
            "    return x, M",
            "",
            "",
            "rem_list = list(map(int, input().split()))",
            "mod_list = [17, 107, 10**9 + 7]",
            "x,M = CRT(rem_list,mod_list)",
            "print(x, M)",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "約数列挙": {
        "prefix": [
            "Lib_N_約数列挙"
        ],
        "body": [
            "##############################",
            "# 約数列挙 O(n**0.5)",
            "# returns sorted list",
            "##############################",
            "def make_divisors(n:int) -> list:",
            "    lower_divisors, upper_divisors = [], []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i != 0: i += 1; continue",
            "        lower_divisors.append(i)",
            "        j = n // i",
            "        if i != j: upper_divisors.append(j)",
            "    return lower_divisors + upper_divisors[::-1]",
            "",
            "#####################",
            "print(make_divisors(10))",
            "#####################",
            "",
            "",
            "##############################",
            "# n!がpで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "素因数分解prime_factorize": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "素因数分解": {
        "prefix": [
            "Lib_N_素因数分解"
        ],
        "body": [
            "##############################",
            "# 素因数分解",
            "# nは10**15くらいまでOK",
            "# returns dict s.t. key = {prime}   value = {degree}",
            "##############################",
            "def prime_factorize(n:int) -> dict:",
            "    if n == 1: return {1: 1}",
            "    pd = dict()",
            "    test = [2] + list(range(3, int(n**0.5)+1, 2))",
            "    for p in test:",
            "        if n % p != 0: continue",
            "        d = 0",
            "        while n % p == 0:",
            "            d += 1",
            "            n //= p",
            "        pd[p] = d",
            "    if n != 1: pd[n] = 1",
            "    return pd",
            "",
            "print(prime_factorize(360))",
            "# 72 = 2**3 * 3**2 * 5**1",
            "# {2: 3, 3: 2, 5: 1}",
            "",
            "##############################",
            "# 素因数分解（複数個版）",
            "# max(A)が大きい場合はNG  10**6くらいまで",
            "# 最初に素数一覧を作っておく",
            "##############################",
            "def prime_factorize(A : list):",
            "    Max = max(A) + 1",
            "    IsPrime = [True] * Max",
            "    MinFactor = [-1] * Max",
            "    dica = {}",
            "    IsPrime[0], IsPrime[1] = False, False",
            "    MinFactor[0], MinFactor[1] = 0, 1",
            "    for p in range(2, Max):",
            "        if IsPrime[p]:",
            "            MinFactor[p] = p",
            "            for k in range(p*2, Max, p):",
            "                IsPrime[k] = False",
            "                if MinFactor[k] == -1:",
            "                    MinFactor[k] = p",
            "",
            "    ret = []",
            "    for a in A:",
            "        res = dict()",
            "        while a != 1:",
            "            prime = MinFactor[a]",
            "            exp = 0",
            "            while MinFactor[a] == prime:",
            "                exp += 1",
            "                a //= prime",
            "            res[prime] = exp",
            "            if not prime in dica:",
            "                dica[prime] = 1",
            "            else:",
            "                dica[prime] += 1",
            "        ret.append(res)",
            "    return ret",
            "",
            "##############################",
            "# n!が素数pで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "素数判定・出力": {
        "prefix": [
            "Lib_N_prime_素数"
        ],
        "body": [
            "",
            "##############################",
            "# 素数判定 O(n**0.5)",
            "##############################",
            "def is_prime(n:int) -> bool:",
            "    if n <= 1: return False",
            "    if n == 2: return True",
            "    if n % 2 == 0: return False",
            "    for i in range(3, int(n**0.5)+1, 2):",
            "        if n % i == 0: return False",
            "    return True",
            "",
            "#####################",
            "print(10, is_prime(10))",
            "print(31, is_prime(31))",
            "#####################",
            "",
            "",
            "##############################",
            "# 素数ミラーラビン判定",
            "# N < 10**18, Q = 10**5回",
            "##############################",
            "",
            "from random import randint as ri",
            "",
            "def miller_rabin(N, Times=10):",
            "    if N == 2: return True",
            "    if N == 1 or N%2 == 0: return False",
            "",
            "    q = N-1",
            "    k = 0",
            "    while q&1==0:",
            "        q >>= 1",
            "        k += 1",
            "",
            "    for _ in range(Times):",
            "        m = ri(2, N-1)",
            "        y = pow(m, q, N)",
            "        if y == 1: continue",
            "",
            "        for _ in range(k):",
            "            if (y+1) % N == 0: break",
            "            y = y * y % N",
            "",
            "        else: return False",
            "    return True",
            "",
            "",
            "for _ in range(int(input())):",
            "    n = int(input())",
            "    print('Yes' if miller_rabin(n, 10) else 'No')",
            "",
            "",
            "##############################",
            "# 素数出力 O(n**0.5)",
            "# n <= 10**5",
            "##############################",
            "def get_primes(n:int) -> list:",
            "# n以下の素数列挙",
            "    isPrime = [False, False, True, True] + [False, True] * ((n - 4) // 2)",
            "    primes = [2]",
            "    for p in range(3, n, 2):",
            "        if isPrime[p]:",
            "           primes.append(p)",
            "           for q in range(p * p, n, p):",
            "               isPrime[q] = False",
            "    return primes",
            "",
            "",
            "##############################",
            "# 素数出力 O(n**0.5)",
            "# 区間篩",
            "# L = 10**14",
            "# R - L <= 10**5",
            "##############################",
            "def get_primes_segments(L:int , R:int) -> list:",
            "    # √R 以下の素数を炙り出すための篩",
            "    sqrtR = int(R**0.5)",
            "    isPrime = [True] * (sqrtR + 1)",
            "    isPrime2 = [True] * (R - L + 1)",
            "    primes = []",
            "    # ふるい",
            "    for p in range(2, sqrtR + 1):",
            "        # すでに合成数であるものはスキップする",
            "        if not isPrime[p]: continue",
            "        # p 以外の p の倍数から素数ラベルを剥奪",
            "        q = p * 2",
            "        while q * q <= R:",
            "            isPrime[q] = False",
            "            q += p",
            "        # L 以上の最小の p の倍数",
            "        start = L + (-L) % p",
            "        if start == p:",
            "            start = p * 2",
            "        # L 以上 R 以下の整数のうち、p の倍数をふるう",
            "        q = start",
            "        while q <= R:",
            "            isPrime2[q - L] = False",
            "            q += p",
            "    primes = [p + L for p, v in enumerate(isPrime2) if v]",
            "    return primes",
            "",
            "",
            "##############################",
            "# n以下の素数の数 O(n**0.5)",
            "# n ～ 10**12 for pypy3",
            "##############################",
            "def count_primes(n:int):",
            "    if n < 2:",
            "        return 0",
            "    v = int(n ** 0.5) + 1",
            "    smalls = [i // 2 for i in range(1, v + 1)]",
            "    smalls[1] = 0",
            "    s = v // 2",
            "    roughs = [2 * i + 1 for i in range(s)]",
            "    larges = [(n // (2 * i + 1) + 1) // 2 for i in range(s)]",
            "    skip = [False] * v",
            "",
            "    pc = 0",
            "    for p in range(3, v):",
            "        if smalls[p] <= smalls[p - 1]:",
            "            continue",
            "",
            "        q = p * p",
            "        pc += 1",
            "        if q * q > n:",
            "            break",
            "        skip[p] = True",
            "        for i in range(q, v, 2 * p):",
            "            skip[i] = True",
            "",
            "        ns = 0",
            "        for k in range(s):",
            "            i = roughs[k]",
            "            if skip[i]:",
            "                continue",
            "            d = i * p",
            "            larges[ns] = larges[k] - \\",
            "                (larges[smalls[d] - pc] if d < v else smalls[n // d]) + pc",
            "            roughs[ns] = i",
            "            ns += 1",
            "        s = ns",
            "        for j in range((v - 1) // p, p - 1, -1):",
            "            c = smalls[j] - pc",
            "            e = min((j + 1) * p, v)",
            "            for i in range(j * p, e):",
            "                smalls[i] -= c",
            "",
            "    for k in range(1, s):",
            "        m = n // roughs[k]",
            "        s = larges[k] - (pc + k - 1)",
            "        for l in range(1, k):",
            "            p = roughs[l]",
            "            if p * p > m:",
            "                break",
            "            s -= smalls[m // p] - (pc + l - 1)",
            "        larges[0] -= s",
            "",
            "    return larges[0]",
            "",
            "",
            "##############################",
            "# n!が素数pで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "ソートアルゴリズム": {
        "prefix": [
            "Lib_O_ソートアルゴリズム_Sort"
        ],
        "body": [
            "def BubbleSort(A, N):",
            "    # 後ろから大きいものを前にスワップしていく",
            "    flag = True",
            "    cnt = 0",
            "    while flag:",
            "        flag = False",
            "        for i in range(1, N)[::-1]:",
            "            if A[i] < A[i-1]:",
            "                A[i], A[i-1] = A[i-1], A[i]",
            "                cnt += 1",
            "                flag = True",
            "    return A, cnt",
            "",
            "def SelectionSort(A, N):",
            "    # 前から最小値を見つけてスワップしていく",
            "    cnt = 0",
            "    for i in range(N):",
            "        minpos = i",
            "        for j in range(i+1, N):",
            "            if A[j] < A[minpos]:",
            "                minpos = j",
            "        if i != minpos:",
            "            A[i], A[minpos] = A[minpos], A[i]",
            "            cnt += 1",
            "    return A, cnt",
            "",
            "n = int(input())",
            "A = list(map(int, input().split()))",
            "",
            "A, cnt = SelectionSort(A, n)",
            "print(*A)",
            "print(cnt)"
        ],
        "description": [
            "ソートアルゴリズム"
        ],
        "scope": "python"
    },
    "各桁の寄与度": {
        "prefix": [
            "Lib_O_各桁の寄与度"
        ],
        "body": [
            "def sum_digit(s, d=10, mod=-1):",
            "    n = len(s)",
            "    ret = 0",
            "",
            "    pow_2 = [1]",
            "    pow_d = [1]",
            "    div = pow(d-2, mod - 2, mod)",
            "    for _ in range(n):",
            "        if mod == -1:",
            "            pow_2.append(pow_2[-1] * 2)",
            "            pow_d.append(pow_d[-1] * d)",
            "        else:",
            "            pow_2.append(pow_2[-1] * 2 % mod)",
            "            pow_d.append(pow_d[-1] * d % mod)",
            "",
            "    def _contribute(k):",
            "        r = pow_2[n-1-k] * ((d-1)* pow_d[k] - pow_2[k])",
            "        if mod == -1:",
            "            r //= d-2",
            "        else:",
            "            r *= div",
            "        return r",
            "",
            "",
            "    for i, si in enumerate(s[::-1]):",
            "        ret += _contribute(i) * int(si) % mod",
            "    return ret % mod",
            "",
            "mod = 998244353",
            "s = input()",
            "print(sum_digit(s, 10, mod))",
            ""
        ],
        "description": [
            "各桁の寄与度",
            "356"
        ],
        "scope": "python"
    },
    "尺取り": {
        "prefix": [
            "Lib_O_尺取り"
        ],
        "body": [
            "######################################################################",
            "# The Smallest Window I",
            "# 長さNの数列a1,a2,a3,...,aNと整数Sが与えられます。",
            "# 要素の総和がS以上となる連続する部分列のうち、",
            "# 最も短いものの長さ（smallest window length）を求めてください。",
            "# ただし、そのような部分列が存在しない場合は 0 と報告してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_A",
            "######################################################################",
            "",
            "N, S = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "INF = 2*N",
            "ret = INF",
            "",
            "l, r, now = 0, 0, 0",
            "while True:",
            "    while r < N and now < S:",
            "        now += A[r]",
            "        r += 1",
            "    if now >=S:",
            "        ret = min(ret, r - l)",
            "        now -= A[l]",
            "        l += 1",
            "    else:",
            "        break",
            "",
            "if ret == INF:",
            "    print(0)",
            "else:",
            "    print(ret)",
            "",
            "######################################################################",
            "# The Smallest Window II",
            "# 長さNの数列a1,a2,a3,...,aNと整数Kが与えられます。",
            "# 1からKまでの整数1, 2, ...,Kをすべて含む連続する部分列のうち、",
            "# 最も短いものの長さ（smallest window length）を求めてください。",
            "# ただし、そのような部分列が存在しない場合は 0 と報告してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_B",
            "######################################################################",
            "",
            "N, K = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "now_each_counter = [0] * (K+1)",
            "now_total_counter = 0",
            "l, r = 0, 0",
            "INF = 2*N",
            "ret = INF",
            "while l < N:",
            "    while r < N and now_total_counter < K:",
            "        ar = A[r]",
            "        if ar <= K:",
            "            now_each_counter[ar] += 1",
            "            if now_each_counter[ar] == 1:",
            "                now_total_counter += 1",
            "        r += 1",
            "    if now_total_counter == K:",
            "        ret = min(ret, r-l)",
            "    al = A[l]",
            "    if al <= K:",
            "        now_each_counter[al] -= 1",
            "        if now_each_counter[al] == 0:",
            "            now_total_counter -= 1",
            "    l += 1",
            "if ret == INF:",
            "    print(0)",
            "else:",
            "    print(ret)",
            "",
            "######################################################################",
            "# The Number of Windows",
            "# 長さNの数列a1,a2,a3,...,aNが与えられます。",
            "# また, 次のような質問がQ個与えられます。",
            "# i個目の質問では,整数x,iが与えられます。",
            "# 各質問について1<=l<=r<=Nかつsum(al,al+1,...,ar-1,ar) <= xiを満たす整数",
            "# (l,r)の組の個数を求めてください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_C",
            "######################################################################",
            "N, Q = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "X = list(map(int, input().split()))",
            "",
            "def solv(x):",
            "    l, r, ret = 0, 0, 0",
            "    now = 0",
            "    while l < N:",
            "        while r < N and now <= x:",
            "            now += A[r]",
            "            r += 1",
            "        if now > x:",
            "            r -= 1",
            "            now -= A[r]",
            "        ret += r - l",
            "        now -= A[l]",
            "        l += 1",
            "    return ret",
            "",
            "for xi in X:",
            "    print(solv(xi))",
            "",
            "######################################################################",
            "# Sliding Minimum Element",
            "# 長さNの数列a1,a2,a3,...,aNと整数Lが与えられます。",
            "# 長さLの連続する部分列すべてについて、",
            "# 各部分列の中の最小の要素を先頭から順番に報告してください。",
            "# 例えば、数列が{1,7,7,4,8,1,6} で、L が 3 の場合、",
            "# 長さLの部分列は{1,7,7},{7,7,4},{7,4,8},{4,8,1},{8,1,6}となりますが、",
            "# それぞれの部分列の最小値となる 1, 4, 4, 1, 1 を先頭の方から順番に出力してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D",
            "######################################################################",
            "from heapq import heapify, heappop, heappush",
            "N, L = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "ret = []",
            "que = []",
            "heapify(que)",
            "for i, ai in enumerate(A):",
            "    heappush(que, (ai, i))",
            "    if i < L-1: continue",
            "    while que[0][1] <= i - L:",
            "        heappop(que)",
            "    ret.append(que[0][0])",
            "print(*ret)",
            ""
        ],
        "description": [
            "Lib_尺取り"
        ],
        "scope": "python"
    },
    "FenwickTree/Binary Indexed Tree": {
        "prefix": [
            "Lib_Q_BIT_Fenwick"
        ],
        "body": [
            "# 部分和の計算と要素の更新の両方を効率的に行える",
            "# 1-indexed",
            "# sum(r)        :閉区間 [0,r] の合計を取得する",
            "# [8] a0 + a1  + a2 + a3 + a4 + a5 + a6 + a7",
            "# [4] a0 + a1  + a2 + a3",
            "# [2] a0 + a1               [6] a4 + a5",
            "# [1] a0       [3] a2       [5] a4        [7] a6",
            "",
            "#                   [1000]",
            "#           [0100]",
            "#   [0010]                [0110]",
            "# [0001]    [0011]      [0111]      [1111]",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def init(self, a):",
            "        for i, x in enumerate(a):",
            "            self.add(i, x)",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def update(self, i, x):",
            "        x -= self[i]",
            "        self.add(i, x)",
            "",
            "    def sum(self, r):",
            "        \"\"\"",
            "        Returns",
            "        -------",
            "        sum of [0, r]",
            "        \"\"\"",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "    def range_sum(self, l, r):",
            "        \"\"\"閉区間 [l,r] の合計を取得する",
            "",
            "        Returns",
            "        -------",
            "        sum of [l, r]",
            "        \"\"\"",
            "        if l == 0:",
            "            return self.sum(r)",
            "        else:",
            "            return self.sum(r) - self.sum(l-1)",
            "",
            "",
            "    def __getitem__(self, i):",
            "        return self.range_sum(i, i)",
            "",
            "",
            "    def right_bound_of_x(self, x):",
            "        # pos       : sum([0, pos]) < x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] <= x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def right_bound_include_x(self, x):",
            "        # pos       : sum([0, pos]) <= x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] < x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def left_bound_of_x(self, x):",
            "        # pos   : x < sum([0, pos])  となる最小のindex",
            "        return self.right_bound_include_x(x) - 1",
            "",
            "    def left_bound_include_x(self, x):",
            "        # pos   : x <= sum([0, pos])  となる最小のindex",
            "        return self.right_bound_of_x(x) - 1",
            "",
            "",
            "#### for debug",
            "    def _get_original_sequence(self):",
            "        ret = [self[i] for i in range(self.size)]",
            "        return ret",
            "",
            "    def _get_aggrigate_sequence(self):",
            "        return [self.sum(i) for i in range(self.size)]",
            "",
            "    def __str__(self):",
            "        seq = self._get_original_sequence()",
            "        ret = 'original :' + ' '.join(map(str, seq))",
            "        ret += '\\n'",
            "        seq = self._get_aggrigate_sequence()",
            "        ret += 'aggrigate:' + ' '.join(map(str, seq))",
            "        return ret",
            "",
            "########################################",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "Ordered set (BIT)": {
        "prefix": [
            "Lib_D_OrderedSet_BIT"
        ],
        "body": [
            "",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def init(self, a):",
            "        for i, x in enumerate(a):",
            "            self.add(i, x)",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def update(self, i, x):",
            "        x -= self[i]",
            "        self.add(i, x)",
            "",
            "    def sum(self, r):",
            "        \"\"\"",
            "        Returns",
            "        -------",
            "        sum of [0, r]",
            "        \"\"\"",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "    def range_sum(self, l, r):",
            "        \"\"\"閉区間 [l,r] の合計を取得する",
            "",
            "        Returns",
            "        -------",
            "        sum of [l, r]",
            "        \"\"\"",
            "        if l == 0:",
            "            return self.sum(r)",
            "        else:",
            "            return self.sum(r) - self.sum(l-1)",
            "",
            "",
            "    def __getitem__(self, i):",
            "        return self.range_sum(i, i)",
            "",
            "",
            "    def right_bound_of_x(self, x):",
            "        # pos       : sum([0, pos]) < x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] <= x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def right_bound_include_x(self, x):",
            "        # pos       : sum([0, pos]) <= x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] < x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def left_bound_of_x(self, x):",
            "        # pos   : x < sum([0, pos])  となる最小のindex",
            "        return self.right_bound_include_x(x) - 1",
            "",
            "    def left_bound_include_x(self, x):",
            "        # pos   : x <= sum([0, pos])  となる最小のindex",
            "        return self.right_bound_of_x(x) - 1",
            "",
            "########################################",
            "class OrderedSet:",
            "    \"\"\"",
            "        init の時に取りえる値を固定",
            "        __contains__: v in XXX",
            "        __len__: len(XXX)",
            "        add(v):",
            "        discard(v):",
            "        index(v): 値vの最初のインデックス(0-index)",
            "        kthvalue(k): 0-indexでのk番目の値",
            "    \"\"\"",
            "    def __init__(self, vals):",
            "        vals = sorted(set(vals))",
            "        INF = max(abs(min(vals)), abs(max(vals)), 10**9)",
            "        INF = pow(10, len(str(INF))+1)",
            "        self.LINF = - INF",
            "        self.RINF = INF",
            "        self.vals = [self.LINF] + vals + [self.RINF]",
            "        self.valtoid = {v: i for i, v in enumerate(self.vals)}",
            "        self.BIT = BinaryIndexedTree(len(self.vals))",
            "        self.size = 0",
            "",
            "    def __contains__(self, v):",
            "        if not v in self.valtoid: return False",
            "        return self.BIT[self.valtoid[v]] >= 1",
            "",
            "    def __len__(self):",
            "        return self.size",
            "",
            "    def add(self, v):",
            "        if v in self.valtoid and not v in self:",
            "            self.size += 1",
            "            self.BIT.update(self.valtoid[v], 1)",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    def discard(self, v):",
            "        if v in self:",
            "            self.BIT.add(self.valtoid[v], -1)",
            "            self.size -= 1",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    def count(self, v):",
            "        if v not in self.valtoid: return -1",
            "        return self.BIT[self.valtoid[v]]",
            "",
            "    def index(self, v):",
            "        if v not in self.valtoid: return -1",
            "        return self.BIT.sum(self.valtoid[v]-1)",
            "",
            "    def left_index(self, v):",
            "        return self.index(v)",
            "",
            "    def right_index(self, v):",
            "        if v not in self.valtoid: return -1",
            "        return self.index(v) + self.count(v)",
            "",
            "    def kth_value(self, k):",
            "        pos = self.BIT.right_bound_of_x(k)",
            "        return self.vals[pos]",
            "",
            "    def prev_value(self, v):",
            "        k = self.left_index(v) - 1",
            "        return self.kth_value(k)",
            "",
            "    def next_value_include_self(self, v):",
            "        \"v以上の値\"",
            "        if self.count(v) > 0: return v",
            "        return self.next_value(v)",
            "",
            "    def next_value(self, v):",
            "        \"vより大きい値\"",
            "        k = self.right_index(v)",
            "        if k == self.size: return self.RINF",
            "        return self.kth_value(k)",
            "",
            "    def __str__(self):",
            "        isfirst = True",
            "        ret = \"{\"",
            "        for v in self.vals:",
            "            if not v in self: continue",
            "            ret += f\"{v}: {self.count(v)}\" if isfirst else f\", {v}: {self.count(v)}\"",
            "            isfirst = False",
            "        ret += \"}\"",
            "        return ret",
            "",
            "",
            "########################################",
            "class OrderedMultiSet(OrderedSet):",
            "    \"\"\"",
            "        count(v): vの個数",
            "        left_index(v): 値vの最初のインデックス(0-index)",
            "        right_index(v): 値vの次の値の最初のインデックス(0-index)",
            "    \"\"\"",
            "    def __init__(self, vals):",
            "        super().__init__(vals)",
            "",
            "    def add(self, v):",
            "        if v in self.valtoid:",
            "            self.BIT.add(self.valtoid[v], 1)",
            "            self.size +=1",
            "            return True",
            "        else:",
            "            return False",
            "",
            "",
            "##################################################",
            "A = [1,2,3,100,100100100,100100, 200200200]",
            "os = OrderedMultiSet(A)",
            "#os = OrderedSet(A)",
            "",
            "os.add(3)",
            "os.add(100)",
            "os.add(100)",
            "os.add(100100100)",
            "# os.add(100100)",
            "# os.add(100100)",
            "print(os.vals)",
            "print(os)",
            "",
            "for i in range(len(os)):",
            "    print(os.kth_value(i))",
            "",
            "for ai in A:",
            "    x = os.index(ai)",
            "    y = os.left_index(ai)",
            "    z = os.right_index(ai)",
            "    pv = os.prev_value(ai)",
            "    nv = os.next_value(ai)",
            "    niv = os.next_value_include_self(ai)",
            "    print(ai, y, z, pv, nv, niv)",
            "",
            "",
            "#print(os.kthvalue(0))"
        ],
        "description": [],
        "scope": "python"
    },
    "遅延評価セグメント木plain": {
        "prefix": [
            "Lib_Q_LazySeg_plain"
        ],
        "body": [
            "from atcoder.lazysegtree import LazySegTree as LazySegTreeACL",
            "",
            "",
            "class LazySegTree(LazySegTreeACL):",
            "    def __init__(self, op, e, mapping, composition, id_, v):",
            "        super().__init__(op, e, mapping, composition, id_, v)",
            "",
            "    def __str__(self) -> str:",
            "        return \" \".join(map(str, [self.get(i) for i in range(self._n)]))",
            "",
            "    def debug(self, xs):",
            "        strs = [str(x) for x in xs] + [f\"({x})\" for x in range(self._n)]",
            "        minsize = max(len(s) for s in strs[self._size :])",
            "        result = [\"|\"] * (self._log + 2)",
            "        level = 0",
            "        next_level = 2",
            "        width = 0",
            "        for i in range(1, len(strs)):",
            "            if i == next_level:",
            "                level += 1",
            "                next_level <<= 1",
            "            if level < self._log + 1:",
            "                width = ((minsize + 1) << (self._log - level)) - 1",
            "            result[level] += strs[i].center(width) + \"|\"",
            "        return \"\\n\".join(result)",
            "",
            "    # https://github.com/atcoder/ac-library/blob/master/document_ja/lazysegtree.md",
            "    # set(p, x): p番目の要素をxに置き換える",
            "    # get(p, x): p番目の要素を取得する",
            "    # prod(l, r): 半開区間[l, r)の計算結果を取得する",
            "    # all_prod(): 全区間[0, self._n)計算結果を取得する",
            "    # apply(l, r, f): 半開区間[l, r)の各要素にfを施す",
            "    # max_right(l, isok): g(v[i])がTrueとなる一番右のindex（lからスタート）",
            "    # min_left(r, isok): g(v[i])がTrueとなる一番左のindex（rからスタート）",
            "",
            "",
            "#######################################################",
            "",
            "# INF = 10 ** 18",
            "# RMinQ and RAQ",
            "# LST = LazySegmentTree(min, INF, lambda f, x: f+x, lambda f, g: f+g, 0, [0]*N)",
            "# RMaxQ and RAQ",
            "# LST = LazySegmentTree(max, -INF, lambda f, x: f+x, lambda f, g: f+g, 0, [0]*N)",
            "# #RSumQ and RAQ",
            "# op = lambda x, y: (x[0]+y[0], x[1]+y[1])",
            "# mp = lambda f, x: (x[0]+f*x[1], x[1])",
            "# LST = LazySegmentTree(op, (0,0), mp, lambda f, g: f+g, 0, [(0,1)]*N)",
            "# #RMinQ and RUQ",
            "# LST = LazySegmentTree(min, INF, lambda f, x: x if f == INF else f, lambda f, g: g if f == INF else f, INF, [INF]*N)",
            "# #RMaxQ and RUQ",
            "# LST = LazySegmentTree(max, -INF, lambda f, x: x if f == -INF else f, lambda f, g: g if f == -INF else f, -INF, [-INF]*N)",
            "# #RSumQ and RUQ",
            "# op = lambda x, y: (x[0]+y[0], x[1]+y[1])",
            "# mp = lambda f, x: x if f == INF else (f*x[1], x[1])",
            "# LST = LazySegmentTree(op, (0,0), mp, lambda f, g: g if f == INF else f, INF, [(0,1)]*N)",
            "",
            "",
            "# https://github.com/ibtosmlin/atcoder/blob/main/lib/lib/Memo_%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1Seg%E6%9C%A8.md",
            "#######################################################",
            "# 区間集約演算 *: G * G -> G の定義.",
            "def op(x, y):",
            "    invx, c0x, c1x = x",
            "    invy, c0y, c1y = y",
            "    return (invx + invy + c0y * c1x, c0x + c0y, c1x + c1y)",
            "",
            "",
            "# op演算の単位元(反転数,区間内の０の数,区間内の１の数)",
            "e = (0, 0, 0)",
            "",
            "",
            "# 区間更新演算 ·: F · G -> G の定義.",
            "def mapping(f, x):",
            "    if f == 0:",
            "        return x",
            "    inv, c0, c1 = x",
            "    return (c1 * c0 - inv, c1, c0)",
            "",
            "",
            "# 遅延評価演算 ·: F · F -> F の定義.",
            "def composition(f, g):",
            "    return f ^ g",
            "",
            "",
            "# 遅延評価演算の単位元",
            "id = 0",
            "",
            "n, q = map(int, input().split())",
            "a = []",
            "for i in map(int, input().split()):",
            "    if i == 1:",
            "        a.append((0, 0, 1))",
            "    else:",
            "        a.append((0, 1, 0))",
            "sgt = LazySegTree(op, e, mapping, composition, id, a)",
            "",
            ""
        ],
        "description": [
            "遅延評価セグメント木",
            ""
        ],
        "scope": "python"
    },
    "双対セグメント木区間x一点": {
        "prefix": [
            "Lib_Q_SegDual_双対_区間更新一点集約"
        ],
        "body": [
            "class SegTree:  # 初期化処理",
            "    \"\"\"dual Segment Tree",
            "    区間＜更新・加算・min・max＞・1点抽出",
            "    Parameters",
            "    ----------",
            "    op: monoid",
            "    e: 単位元",
            "    v : 初期リスト/要素数",
            "    Notes",
            "    -----",
            "    \"\"\"",
            "    def __init__(self, op, e, v):",
            "        self._op = op",
            "        self._e = (-1, e)",
            "",
            "        if isinstance(v, int):",
            "            v = [e] * v",
            "",
            "        self._n = len(v)",
            "        self._log = (self._n - 1).bit_length()",
            "        self._size = 1 << self._log",
            "        self._time = 0",
            "        self._d = [self._e] * (2 * self._size)",
            "",
            "        for i in range(self._n):",
            "            self._d[self._size + i] = (-1, v[i])",
            "        for i in range(self._n):",
            "            self._query(i)",
            "",
            "    def update(self, l, r, x):",
            "        \"\"\"半開区間[l, r)の値を更新",
            "        \"\"\"",
            "        _x = (self._time, x)",
            "        l += self._size",
            "        r += self._size",
            "        while l < r:",
            "            if r & 1:",
            "                r -= 1; self._d[r] = self._op(self._d[r], _x)",
            "            if l & 1:",
            "                self._d[l] = self._op(self._d[l], _x); l += 1",
            "            l >>= 1; r >>= 1",
            "        self._time += 1",
            "",
            "    def _query(self, k) -> tuple:",
            "        k += self._size",
            "        t = self._e",
            "        while k > 0:",
            "            if self._d[k]:",
            "                t = self._op(t, self._d[k])",
            "            k >>= 1",
            "        return t",
            "",
            "    def query(self, k: int) -> int:",
            "        \"\"\"a_kを取得",
            "        \"\"\"",
            "        return self._query(k)[1]",
            "",
            "    def __getitem__(self, i:int) -> tuple:",
            "        return self.query(i)",
            "",
            "    def __str__(self):",
            "        \"\"\"元のリストの値を表示\"\"\"",
            "        return self._debug(self._d)",
            "",
            "    def debug(self):",
            "        strs = [\"e\" if x == self._e else str(x) for x in self._d] + [f\"({x})\" for x in range(self._n)]",
            "        minsize = max(len(s) for s in strs[self._size:])",
            "        result = [\"|\"] * (self._log + 2)",
            "        level = 0",
            "        next_level = 2",
            "        for i in range(1, len(strs)):",
            "            if i == next_level:",
            "                level += 1",
            "                next_level <<= 1",
            "            if level < self._log + 1:",
            "                width = ((minsize + 1) << (self._log - level)) - 1",
            "            result[level] += strs[i].center(width) + \"|\"",
            "        return \"\\n\".join(result)",
            "",
            "",
            "",
            "n, q = map(int, input().split())",
            "INF = (1<<31) - 1",
            "",
            "RUQ = SegTree(lambda x, y: max(x, y), INF, n)",
            "RAQ = SegTree(lambda x, y: (max(x[0], y[0]), x[1]+y[1]), 0, n)",
            "RMinQ = SegTree(lambda x, y: (max(x[0], y[0]), min(x[1],y[1])), INF, n)",
            "RMaxQ = SegTree(lambda x, y: (max(x[0], y[0]), max(x[1],y[1])), INF, n)",
            "",
            "",
            "# 1-indexed",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_D",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_E",
            "",
            "for _ in range(q):",
            "    t, *qry = map(int, input().split())",
            "    if t == 0:",
            "        l, r, x = qry",
            "        # l -= 1",
            "        r += 1",
            "        RUQ.update(l, r, x)",
            "    else:",
            "        i = qry[0]",
            "        # i -= 1",
            "        print(RUQ.query(i))",
            "    print(RUQ.debug())"
        ],
        "description": [
            "双対セグメント木区間x一点"
        ],
        "scope": "python"
    },
    "セグメント木１点更新区間集約": {
        "prefix": [
            "Lib_Q_Seg_一点更新区間集約"
        ],
        "body": [
            "",
            "from atcoder.segtree import SegTree as SegTreeACL",
            "",
            "class SegTree(SegTreeACL):",
            "    def __init__(self, op, e, v) -> None:",
            "        super().__init__(op, e, v)",
            "",
            "    def __getitem__(self, i):",
            "        return self._d[i + self._size]",
            "",
            "    def __str__(self):",
            "        \"\"\"元のリストの値を表示",
            "        \"\"\"",
            "        return ' '.join(map(str, (self[i] for i in range(self._n))))",
            "",
            "    def debug(self) -> None:",
            "        strs = [\"e\" if x == self._e else str(x) for x in self._d] + [f\"({i})\" for i in range(self._n)]",
            "        minsize = max(len(s) for s in strs[self._size:])",
            "        result = [\"|\"] * (self._log + 2)",
            "        level = 0",
            "        next_level = 2",
            "        for i in range(1, len(strs)):",
            "            if i == next_level:",
            "                level += 1",
            "                next_level <<= 1",
            "            if level < self._log + 1:",
            "                width = ((minsize + 1) << (self._log - level)) - 1",
            "            result[level] += strs[i].center(width) + \"|\"",
            "        return \"\\n\".join(result)",
            "",
            "# def max_right(self, l, isOk):",
            "    # ex:",
            "    # maxの場合 a[l]  a[r-1] が isOKとなる最大の値",
            "    # (1): 関数 bool isOk(x) を定義し、segtreeの上で二分探索をする。",
            "    # (2): 木の値を引数にとりboolを返す関数オブジェクトを渡して使用します。",
            "    # r = l もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "    # r = n もしくは f(op(a[l], a[l + 1], ..., a[r])) = false",
            "    # fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最大のr",
            "",
            "# def min_left(self, r, isOk):",
            "#     l = r もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "#     l = 0 もしくは f(op(a[l-1], a[l], ..., a[r-1])) = false",
            "#     fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最小のl",
            "",
            "####################################",
            "\"\"\"Range MAX\"\"\"",
            "# op = max; e = -10**18 #or 0",
            "\"\"\"Range MIN\"\"\"",
            "# op = min; e = 10**18 #or 9999",
            "\"\"\"Range SUM\"\"\"",
            "# op = lambda x, y: x + y; e = 0",
            "\"\"\"Range Prod\"\"\"",
            "# op = lambda x, y: x * y; e = 1",
            "\"\"\"Range Xor\"\"\"",
            "# op = lambda x, y: x ^ y; e = 0",
            "\"\"\"Range GCD\"\"\"",
            "# import math",
            "# def op(x, y):",
            "#     if x == 0: return y",
            "#     if y == 0: return x",
            "#     return math.gcd(x, y)",
            "# e = 0",
            "",
            "\"\"\"区間の右と左の情報を持って、区間の情報を集約するタイプ\"\"\"",
            "# https://atcoder.jp/contests/abc415/tasks/abc415_f",
            "# class T:",
            "#     def __init__(self, S=\"~\"):",
            "#         self.covered: bool = True",
            "#         self.mv: int = int(S!=\"~\")",
            "#         self.leftc: str = S",
            "#         self.leftv: int = int(S!=\"~\")",
            "#         self.rightc: str = S",
            "#         self.rightv: int = int(S!=\"~\")",
            "",
            "#     def __str__(self):",
            "#         return f\"{self.covered}|{self.mv}|({self.leftc},{self.leftv})|({self.rightc}, {self.rightv})\"",
            "",
            "# def op(x:T, y:T)->T:",
            "#     if x.mv == 0:",
            "#         return y",
            "#     if y.mv == 0:",
            "#         return x",
            "",
            "#     xy = T()",
            "#     xy.covered = False",
            "#     xy.mv = max(x.mv, y.mv)",
            "#     xy.leftc = x.leftc",
            "#     xy.leftv = x.leftv",
            "#     xy.rightc = y.rightc",
            "#     xy.rightv = y.rightv",
            "",
            "#     if x.rightc == y.leftc:",
            "#         if x.covered and y.covered:",
            "#             xy.covered = True",
            "#             xy.rightv = xy.leftv = xy.mv = x.mv + y.mv",
            "#         else:",
            "#             xy.mv = max(xy.mv, x.rightv + y.leftv)",
            "#             xy.leftv = x.rightv + y.leftv if x.covered else x.leftv",
            "#             xy.rightv = x.rightv + y.leftv if y.covered else y.rightv",
            "",
            "#     return xy",
            "",
            "####################################",
            "# https://atcoder.jp/contests/practice2/tasks/practice2_j",
            "n, q = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "op = max; e = -10**18 #or 0",
            "sgt = SegTree(op, e, A)",
            "for _ in range(q):",
            "    t, u, v = map(int, input().split())",
            "    if t == 1:",
            "        sgt.set(u-1, v)",
            "    elif t == 2:",
            "        print(sgt.prod(u-1, v))",
            "    else:",
            "        print(sgt.max_right(u-1, lambda y: y<v) + 1)",
            ""
        ],
        "description": [
            "セグメント木１点更新区間集約"
        ],
        "scope": "python"
    },
    "ゾブリストハッシュ": {
        "prefix": [
            "Lib_Set_ZobristHash"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc250/tasks/abc250_e -> Hash",
            "# https://atcoder.jp/contests/abc367/tasks/abc367_f -> MultiHash",
            "",
            "import random",
            "",
            "class MultiHash:",
            "    def __init__(self):",
            "        self.mod = None",
            "        self.hash = []",
            "",
            "    def get(self, l, r):",
            "        # returns hashvalue of [l, r)",
            "        h = self.hash",
            "        return (h[r] - h[l]) % self.mod",
            "",
            "class Hash:",
            "    def __init__(self):",
            "        self.hash = []",
            "",
            "    def get(self, l, r):",
            "        # returns hashvalue of [l, r)",
            "        h = self.hash",
            "        return h[r] ^ h[l]",
            "",
            "class ZobristHash:",
            "    def __init__(self, elements: set|list, mod: int = (1<<61)-1):",
            "        self.hash_table = {}",
            "        self.mod = mod",
            "        for e in elements:",
            "            if e in self.hash_table: continue",
            "            self.hash_table[e]= random.randint(1, mod)",
            "",
            "",
            "    def create_MultiHash(self, X:list):",
            "        hashstruct = MultiHash()",
            "        hashX = [0]",
            "        for x in X:",
            "            hashX.append((hashX[-1] + self.hash_table[x]) % self.mod)",
            "        hashstruct.mod = self.mod",
            "        hashstruct.hash = hashX",
            "        return hashstruct",
            "",
            "    def create_Hash(self, X:list):",
            "        hashstruct = Hash()",
            "        hashX = [0]",
            "        seen = set()",
            "        for x in X:",
            "            if x in seen:",
            "                hashX.append(hashX[-1])",
            "            else:",
            "                hashX.append(hashX[-1] ^ self.hash_table[x])",
            "            seen.add(x)",
            "        hashstruct.hash = hashX",
            "        return hashstruct",
            "",
            "N = int(input())",
            "A = list(map(int, input().split()))",
            "B = list(map(int, input().split()))",
            "",
            "zob = ZobristHash(A+B)",
            "hashA = zob.create_Hash(A)",
            "hashB = zob.create_Hash(B)",
            "",
            "Q = int(input())",
            "for i in range(Q):",
            "    x, y = map(int, input().split())",
            "    print(\"Yes\" if hashA.get(0, x) == hashB.get(0, y) else \"No\")",
            "",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "ダイクストラ法": {
        "prefix": [
            "Lib_SP_最短経路探索_dijkstra"
        ],
        "body": [
            "# ダイクストラ法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 有向グラフで優先度付きキューで探索",
            "# https://atcoder.jp/contests/abc035/tasks/abc035_d",
            "# O((E+V)logV)",
            "from heapq import heapify, heappop, heappush",
            "class dijkstra:",
            "    def __init__(self, n, G):",
            "        self.INF = 10**9",
            "        self.n = n                  # ノード数",
            "        self.G = G                  # 有向グラフ",
            "        self.start = None           # 始点",
            "        self.G_used = [None] * n    # 最短経路木の親",
            "        self.dist = [self.INF] * n  # 始点からの距離",
            "        # self.count = [0] * n        # 始点からの最短到達パス数",
            "",
            "    def build(self, start):",
            "        self.start = start",
            "        self.G_used = [None] * self.n",
            "        self.dist = [self.INF] * self.n",
            "        # self.count = [0] * self.n",
            "        next_q = []",
            "        if type(start) is int:",
            "            start = [start]",
            "        for st in start:",
            "            self.dist[st] = 0",
            "            # self.count[st] = 1",
            "            next_q.append((0, st))",
            "        heapify(next_q)",
            "        while next_q:",
            "            d, x = heappop(next_q)",
            "            if self.dist[x] < d: continue",
            "            for nx, d_nx_x in self.G[x]:",
            "                # 変則的な距離の場合はここを調整 ##",
            "                nd = self.dist[x] + d_nx_x",
            "                ############################",
            "                if self.dist[nx] < nd: continue",
            "                if self.dist[nx] == nd:",
            "                    # self.count[nx] += self.count[x]",
            "                    continue",
            "                self.dist[nx] = nd",
            "                self.G_used[nx] = x",
            "                # self.count[nx] = self.count[x]",
            "                heappush(next_q, (nd, nx))",
            "",
            "",
            "    def get_dist(self, goal):",
            "        # 各ノードへの最短距離",
            "        return self.dist[goal]",
            "",
            "",
            "    def get_count(self, goal):",
            "        # 各ノードへの最短距離のパス数",
            "        return self.count[goal]",
            "",
            "",
            "    def get_path(self, goal):",
            "        # 各ノードへの最短パス",
            "        path = []",
            "        node = goal",
            "        while node != None:",
            "            path.append(node)",
            "            node = self.G_used[node]",
            "        return path[::-1]",
            "",
            "##########################################",
            "",
            "n, m, t = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "G_R = [[] for _ in range(n)]    #行きと帰りを分けた（有向グラフ）場合",
            "#リストの作成",
            "for _ in range(m):",
            "    a, b, c = map(int, input().split())",
            "    a, b = a-1, b-1",
            "    G[a].append((b,c))",
            "    G[b].append((a,c))",
            "    G_R[b].append((a,c))        #行きと帰りを分けた（有向グラフ）場合",
            "",
            "dij = dijkstra(n, G)  #クラスのインスタンス化",
            "dijR = dijkstra(n, G_R)",
            "dij.build(0)",
            "dijR.build(0)",
            "",
            "print(dij.get_dist(n-1))",
            "",
            "",
            "",
            "####################################",
            "\"G = [[INF] * n for _ in range(n)] 版\"",
            "",
            "from heapq import heappop, heappush",
            "def dijkstra(n, G, start):",
            "    INF = 10 ** 20",
            "    dist = [INF] * n",
            "    dist[start] = 0",
            "    que = [(0, start)]",
            "    while que:",
            "        d, x = heappop(que)",
            "        if d != dist[x]: continue",
            "        for nx in range(n):",
            "            if x == nx: continue",
            "            nd = d + G[x][nx]",
            "            if nd >= dist[nx]: continue",
            "            dist[nx] = nd",
            "            heappush(que, (nd, nx))",
            "    return dist",
            "",
            ""
        ],
        "description": [
            "ダイクストラ法",
            "辺の重みが小さいものから、決めていく",
            ""
        ],
        "scope": "python"
    },
    "ベルマンフォード法": {
        "prefix": [
            "Lib_SP_最短経路探索_bellmanford"
        ],
        "body": [
            "# ベルマンフォード法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 辺を繰り返しみて、最小化していく",
            "# |V|回更新するとで収束する/しなければ、負の閉路がある",
            "",
            "# https://atcoder.jp/contests/abc061/tasks/abc061_d",
            "",
            "def bellman_ford(G, st=0):",
            "    \"\"\"",
            "    n: グラフの頂点数",
            "    st: 始点",
            "    G[v] = [(w, cost), ...]: 頂点vからコストcostで到達できる頂点w",
            "    returns",
            "    dist or -1 if 閉路あり",
            "    \"\"\"",
            "",
            "    INF = 1e18",
            "    dist = [INF] * n",
            "    dist[st] = 0",
            "    prev = [-1] * n",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                prev[t] = v",
            "                update = True",
            "                upi = t",
            "        if not update: return dist  # prev",
            "    # 負閉路検出処理",
            "    dist[upi] = -INF",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                update = True",
            "                upi = t",
            "        if not update: return dist",
            "    return -1",
            "",
            "######################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "# 隣接リストの作成",
            "for _ in range(m):",
            "    _a, _b, _c = map(int, input().split())",
            "    _a -= 1; _b -= 1",
            "    G[_a].append((_b, -_c))",
            "",
            "st = 0",
            "ret = bellman_ford(G, st)",
            "if ret == -1:",
            "    print('inf')",
            "else:",
            "    print(-ret[-1])",
            ""
        ],
        "description": [
            "ベルマンフォード法・負閉路OK",
            "O(NM)"
        ],
        "scope": "python"
    },
    "ワーシャルフロイド法": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "全頂点間最短路": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "d[i][j]は2頂点間i, j間の移動コストを格納, Nは頂点数": {
        "prefix": [],
        "body": [],
        "description": [],
        "scope": "python"
    },
    "O(N^3)": {
        "prefix": [
            "Lib_SP_最短経路探索_warshall"
        ],
        "body": [
            "",
            "class WarshallFloyd:",
            "    INF = 10**18",
            "    directed = False    # 無向: False   有向: True",
            "    def __init__(self, n:int) -> None:",
            "        self.n = n",
            "        self.dist = [[self.INF] * n for _ in range(n)]",
            "        for i in range(n):",
            "            self.dist[i][i] = 0",
            "",
            "",
            "    def add_edge(self, fm: int, to: int, cost: int):",
            "        \"\"\"辺の追加\"\"\"",
            "        if self.dist[fm][to] <= cost: return",
            "        self.dist[fm][to] = cost",
            "        if self.directed: return",
            "        self.dist[to][fm] = cost",
            "",
            "    def build(self):",
            "        if self.directed:",
            "            self._build_directed()",
            "        else:",
            "            self._build_nodirected()",
            "",
            "",
            "    def _build_directed(self):",
            "        \"\"\"O(N^3)計算\"\"\"",
            "        n = self.n",
            "        dist = self.dist",
            "        for k in range(n):",
            "            for i in range(n):",
            "                if dist[i][k] == self.INF: continue",
            "                for j in range(i):",
            "                    if dist[k][j] == self.INF: continue",
            "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])",
            "                    dist[j][i] = dist[i][j]",
            "        self.dist = dist",
            "",
            "    def _build_nodirected(self):",
            "        \"\"\"O(N^3)計算\"\"\"",
            "        n = self.n",
            "        dist = self.dist",
            "        for k in range(n):",
            "            for i in range(n):",
            "                if dist[i][k] == self.INF: continue",
            "                for j in range(n):",
            "                    if dist[k][j] == self.INF: continue",
            "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])",
            "        self.dist = dist",
            "",
            "",
            "    def update_edge(self, fm, to, cost):",
            "        \"\"\"特定の辺を更新\"\"\"",
            "        dist = self.dist",
            "        if dist[fm][to] <= cost:",
            "            return",
            "        dist[fm][to] = cost",
            "        if not self.directed:",
            "            dist[to][fm] = cost",
            "        for i in range(n):",
            "            for j in range(n):",
            "                dist[i][j] = min(dist[i][j], dist[i][fm] + cost + dist[to][j])",
            "                if not self.directed:",
            "                    dist[i][j] = min(dist[i][j], dist[i][to] + cost + dist[fm][j])",
            "        self.dist = dist",
            "",
            "",
            "    @property",
            "    def is_neg_cycle(self) -> bool:",
            "        \"\"\"負値閉路検索\"\"\"",
            "        for i in range(self.n):",
            "            if self.wf[i][i] < 0:",
            "                return True",
            "        return False",
            "",
            "",
            "    def path(self, s: int, g: int):",
            "        \"\"\"経路復元\"\"\"",
            "        ret = []",
            "        if s == g or self.wf[s][g] == self.INF:",
            "            return ret",
            "        cur = s",
            "        while cur!=g:",
            "            for nxt in range(self.n):",
            "                if nxt==cur or nxt==s: continue",
            "                if self.d[cur][nxt] + self.wf[nxt][g] == self.wf[cur][g]:",
            "                    ret.append((cur, nxt))",
            "    #                ret.append((nxt, cur))",
            "                    cur = nxt",
            "                    break",
            "        return ret",
            "",
            "##############################",
            "",
            "n, m = map(int,input().split()) #N:頂点数 m:辺の数",
            "",
            "wf = WarshallFloyd(n)",
            "",
            "for _ in range(m):",
            "    u, v, w = map(int,input().split())",
            "    u -= 1; v -= 1",
            "    wf.add_edge(u, v, w)",
            "#    wf.add_edge(v, u, w)",
            "",
            "wf.build()",
            "",
            "print(wf.path(0, n-1))",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "ローリングハッシュ": {
        "prefix": [
            "Lib_Str_RollingHash"
        ],
        "body": [
            "# https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bd",
            "",
            "from random import randint",
            "mod1 = 2**61 - 1",
            "mod2 = 1000000007",
            "base1 = randint(1,mod1-1)",
            "base2 = randint(1,mod2-1)",
            "",
            "class RollingHash:",
            "    mod1 = mod1",
            "    mod2 = mod2",
            "    base1 = base1",
            "    base2 = base2",
            "    def __init__(self, S:str) -> None:",
            "        self.S = S",
            "        self.size = len(S)",
            "        self.hash1 = [0] * (n + 1)",
            "        self.hash2 = [0] * (n + 1)",
            "        self.power1 = [1] * (n + 1)",
            "        self.power2 = [1] * (n + 1)",
            "",
            "        for i in range(self.size):",
            "            self.hash1[i+1] = (self.hash1[i] * self.base1 + ord(S[i])) % self.mod1",
            "            self.hash2[i+1] = (self.hash2[i] * self.base2 + ord(S[i])) % self.mod2",
            "            self.power1[i+1] = (self.power1[i] * self.base1) % self.mod1",
            "            self.power2[i+1] = (self.power2[i] * self.base2) % self.mod2",
            "",
            "    def get(self, l:int, r:int) -> tuple:",
            "        \"\"\"部分文字列 S[l:r] のハッシュ取得\"\"\"",
            "        res1 = (self.hash1[r] - self.hash1[l] * self.power1[r - l]) % self.mod1",
            "        res2 = (self.hash2[r] - self.hash2[l] * self.power2[r - l]) % self.mod2",
            "        return (res1, res2)",
            "",
            "    def getLCP(self, a:int, b:int) -> int:",
            "        \"\"\"S[a:] と S[b:] の最長共通接頭辞の長さ\"\"\"",
            "        len_ = min(self.size - a, self.size - b)",
            "        low, high = 0, len_",
            "        while high - low > 1:",
            "            mid = (low + high) // 2",
            "            if self.get(a, a + mid) != self.get(b, b + mid):",
            "                high = mid",
            "            else:",
            "                low = mid",
            "        return low",
            "",
            "    def getLCP_with(self, a:int, other_hash, b:int):",
            "        \"\"\"自身の文字列 S[a:] と、別の文字列 T[b:] の最長共通接頭辞の長さ\"\"\"",
            "        len_ = min(self.size - a, other_hash.size - b)",
            "        low, high = 0, len_",
            "        while high - low > 1:",
            "            mid = (low + high) // 2",
            "            if self.get(a, a + mid) != other_hash.get(b, b + mid):",
            "                high = mid",
            "            else:",
            "                low = mid",
            "        return low",
            "",
            "",
            "n, q = map(int, input().split())",
            "s = input()",
            "RHS = RollingHash(s)",
            "",
            "for _ in range(q):",
            "    a, b, c, d = map(int, input().split())",
            "    a -= 1; c -= 1",
            "    hash1 = RHS.get(a, b)",
            "    hash2 = RHS.get(c, d)",
            "",
            "    if hash1 == hash2:",
            "        print('Yes')",
            "    else:",
            "        print('No')",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "動的ローリングハッシュ(１点更新)": {
        "prefix": [
            "Lib_Str_RollingHash"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc331/tasks/abc331_f",
            "",
            "from atcoder.segtree import SegTree",
            "from random import randint",
            "n = 10**6",
            "mod = 2**61 - 1",
            "base = randint(1,mod-1)",
            "pw = [1]",
            "for _ in range(n):",
            "    pw.append(pw[-1]*base%mod)",
            "",
            "",
            "def op(x, y):",
            "    # xh: ハッシュ値, xl: 区間の長さ",
            "    xh, xl = x",
            "    yh, yl = y",
            "    nh = (xh * pw[yl] % mod + yh) % mod",
            "    nl = xl + yl",
            "    return (nh, nl)",
            "",
            "",
            "class RollingHashSegTree:",
            "    def __init__(self, S: str) -> None:",
            "        self.sgt = SegTree(op, (0,0), [(ord(c), 1) for c in S])",
            "        self.size = len(S)",
            "",
            "    def update(self, i: int, c: str) -> None:",
            "        self.sgt.set(i, (ord(c), 1))",
            "",
            "    def get(self, l: int, r:int) -> int:",
            "        return self.sgt.prod(l, r)",
            "",
            "    def getLCP(self, a:int, b:int) -> int:",
            "        \"\"\"S[a:] と S[b:] の最長共通接頭辞の長さ\"\"\"",
            "        len_ = min(self.size - a, self.size - b)",
            "        low, high = 0, len_",
            "        while high - low > 1:",
            "            mid = (low + high) // 2",
            "            if self.get(a, a + mid) != self.get(b, b + mid):",
            "                high = mid",
            "            else:",
            "                low = mid",
            "        return low",
            "",
            "    def getLCP_with(self, a:int, other_hash, b:int):",
            "        \"\"\"自身の文字列 S[a:] と、別の文字列 T[b:] の最長共通接頭辞の長さ\"\"\"",
            "        len_ = min(self.size - a, other_hash.size - b)",
            "        low, high = 0, len_",
            "        while high - low > 1:",
            "            mid = (low + high) // 2",
            "            if self.get(a, a + mid) != other_hash.get(b, b + mid):",
            "                high = mid",
            "            else:",
            "                low = mid",
            "        return low",
            "",
            "",
            "n, q = map(int, input().split())",
            "s = input()",
            "left = RollingHashSegTree(s)",
            "right = RollingHashSegTree(s[::-1])",
            "",
            "for _ in range(q):",
            "    query = list(input().split())",
            "    if query[0] == \"1\":",
            "        x, c = query[1:]",
            "        x = int(x) - 1",
            "        left.update(x, c)",
            "        right.update(n-1-x, c)",
            "    else:",
            "        l, r = map(int, query[1:])",
            "        print('Yes' if left.get(l-1, r) == right.get(n-r, n-l+1) else 'No')",
            ""
        ],
        "description": [],
        "scope": "python"
    },
    "SuffixArray": {
        "prefix": [
            "Lib_Str_SuffixArray"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc362/tasks/abc362_g",
            "",
            "from atcoder.string import suffix_array",
            "",
            "s = input()",
            "sa = suffix_array(s)",
            "n = len(s)",
            "",
            "def bisect_left(t: str) -> int:",
            "    # bisect_left: tが入るべき一番左",
            "    ok = -1",
            "    ng = n",
            "    lt = len(t)",
            "    while ng - ok > 1:",
            "        mid = (ok+ng)//2",
            "        pos = sa[mid]",
            "        if s[pos:pos+lt] < t:",
            "            ok = mid",
            "        else:",
            "            ng = mid",
            "    return ok",
            "",
            "def bisect_right(t: str) -> int:",
            "    return bisect_left(t + \"~\")",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    t = input()",
            "    ret = bisect_right(t) - bisect_left(t)",
            "    print(ret)",
            ""
        ],
        "description": [
            "SuffixArray"
        ],
        "scope": "python"
    },
    "Trie木": {
        "prefix": [
            "Lib_Str_共通接頭辞_Trie木"
        ],
        "body": [
            "",
            "class TrieTree:",
            "    class Node:",
            "        \"\"\"",
            "        \"\"\"",
            "        def __init__(self, char:str = \"\") -> None:",
            "            self.char = char            #この文字列の階層の文字列",
            "            self.children:dict = {}     #下位層",
            "            self.parent:\"Node\" | None = None    #親ノード",
            "            self.word_count:int = 0     #この文字列の個数",
            "            self.prefix_count:int = 0   #このprefixで始まる文字列の個数",
            "            self.parent_count:int = 0   #この文字列のprefixの文字列の数",
            "            self.length:int = 0         #文字列数",
            "",
            "        @property",
            "        def is_end(self) -> bool:",
            "            \"\"\"この文字列が存在するか\"\"\"",
            "            return self.word_count > 0",
            "",
            "        @property",
            "        def ancestor_word(self) -> \"Node\":",
            "            \"\"\"祖先の文字列\"\"\"",
            "            current = self",
            "            while current.parent is not None:",
            "                current = current.parent",
            "                if current.is_end: break",
            "            return current",
            "",
            "        @property",
            "        def ancestor_branch(self) -> \"Node\":",
            "            \"\"\"祖先の分岐\"\"\"",
            "            current = self",
            "            while current.parent is not None:",
            "                current = current.parent",
            "                if len(current.children)>=2 or current.is_end: break",
            "            return current",
            "",
            "        @property",
            "        def child_count(self) -> int:",
            "            \"\"\"子供の数\"\"\"",
            "            return self.prefix_count - self.word_count",
            "",
            "        def __str__(self):",
            "            ret = [self.char]",
            "            current = self",
            "            while current.parent is not None:",
            "                current = current.parent",
            "                ret.append(current.char)",
            "            return \"\".join(reversed(ret))",
            "",
            "    def __init__(self):",
            "        self.root = self.Node()",
            "",
            "    def add(self, string):",
            "        \"\"\"文字列を追加\"\"\"",
            "        self._add(string)",
            "",
            "    def discard(self, string):",
            "        \"\"\"文字列を削除\"\"\"",
            "        self._discard(string)",
            "",
            "    def find(self, string):",
            "        \"\"\"文字列のノード\"\"\"",
            "        return self._contains(string)[1]",
            "",
            "    def contains(self, string):",
            "        \"\"\"文字列が存在するか\"\"\"",
            "        return self._contains(string)[0]",
            "",
            "    def __contains__(self, string):",
            "        return self._contains(string)[0]",
            "",
            "    def contains_prefix(self, string):",
            "        \"\"\"stringの接頭辞である文字列が存在するか\"\"\"",
            "        return self._contains_prefix(string)",
            "",
            "    def count_lcp(self, string):",
            "        \"\"\"stringとのLCPの長さとその文字列の個数{長さ: 個数, }\"\"\"",
            "        return self._count_lcp(string)",
            "",
            "    def count_words_with_prefix(self, prefix):",
            "        \"\"\"prefixで始まる文字列の個数\"\"\"",
            "        return self._count_words_with_prefix(prefix)",
            "",
            "    def get_words_with_prefix(self, prefix):",
            "        \"\"\"prefixで始まる文字列を辞書順に列挙\"\"\"",
            "        return self._get_words_with_prefix(prefix)",
            "",
            "    def count_all_words(self):",
            "        \"\"\"この木に入っているすべての文字列の個数\"\"\"",
            "        return self._count_words_with_prefix(\"\")",
            "",
            "    def enumerate_all_words(self):",
            "        \"\"\"すべての文字列を辞書順に列挙\"\"\"",
            "        return self._get_words_with_prefix(\"\")",
            "",
            "    def get_kth_word(self, k):",
            "        \"\"\"辞書順でk番目の要素を取得(0-indexed)\"\"\"",
            "        return self._get_kth_word(k)",
            "",
            "    def init(self, string=\"\"):",
            "        \"\"\"文字列以降の情報を更新\"\"\"",
            "        def dfs(node):",
            "            child_count = 0",
            "            for nextnode in node.children.values():",
            "                nextnode.parent_count = node.parent_count + node.word_count",
            "                child_count += dfs(nextnode)",
            "            node.prefix_count = child_count + node.word_count",
            "            return node.prefix_count",
            "",
            "        node = self.find(string)",
            "        if node is None: return",
            "        dfs(node)",
            "        return",
            "",
            "    def __str__(self):",
            "        return f'{self.enumerate_words()}'",
            "",
            "    def _add(self, string):",
            "        self.root.prefix_count += 1",
            "        current = self.root",
            "        for char in string:",
            "            if char not in current.children:",
            "                current.children[char] = self.Node(char)",
            "                current.children[char].parent = current",
            "                current.children[char].length = current.length + 1",
            "            current = current.children[char]",
            "            current.prefix_count += 1",
            "        current.word_count += 1",
            "",
            "    def _discard(self, string):",
            "        if not self._contains(string):",
            "            return",
            "        self.root.prefix_count -= 1",
            "        current = self.root",
            "        for char in string:",
            "            current.children[char].prefix_count -= 1",
            "            if current.children[char].prefix_count == 0:",
            "                del current.children[char]",
            "                return",
            "            current = current.children[char]",
            "        current.word_count -= 1",
            "",
            "    def _traverse(self, string):",
            "        \"\"\"stringに基づいてノードをたどる\"\"\"",
            "        current = self.root",
            "        for char in string:",
            "            if char not in current.children:",
            "                return None",
            "            current = current.children[char]",
            "        return current",
            "",
            "    def _contains(self, string):",
            "        node = self._traverse(string)",
            "        if node is None:",
            "            return False, node",
            "        return node.is_end, node",
            "",
            "    def _contains_prefix(self, string):",
            "        current = self.root",
            "        for char in string:",
            "            if char not in current.children:",
            "                return False",
            "            current = current.children[char]",
            "            if current.is_end:",
            "                return True",
            "        return False",
            "",
            "    def _count_lcp(self, string):",
            "        current = self.root",
            "        #先頭i文字が等しい文字列の個数を数えてから",
            "        lcp_count = [self.count_all_words()] + [0] * len(string)",
            "        for i, char in enumerate(string, 1):",
            "            if char not in current.children:",
            "                break",
            "            current = current.children[char]",
            "            lcp_count[i] = current.prefix_count",
            "",
            "        for i in range(len(string)):",
            "            lcp_count[i] -= lcp_count[i+1]",
            "        return lcp_count",
            "",
            "    def _count_words_with_prefix(self, prefix):",
            "        node = self._traverse(prefix)",
            "        if node is None:",
            "            return 0",
            "        return node.prefix_count",
            "",
            "    def _get_words_with_prefix(self, prefix):",
            "        node = self._traverse(prefix)",
            "        if node is None:",
            "            return []",
            "",
            "        words = []",
            "        word = [prefix[:-1]]",
            "        stack = [node]",
            "        while stack: #dfs",
            "            node = stack.pop()",
            "            if node is None: #帰りなら",
            "                word.pop()",
            "                continue",
            "            word.append(node.char)",
            "            #ノードが終端ならその数だけ答えに追加",
            "            words.extend([''.join(word) for _ in range(node.word_count)])",
            "            stack.append(None) #帰り用",
            "            for _, next in sorted(node.children.items(), reverse=True):",
            "                stack.append(next)",
            "        return words",
            "",
            "    def _get_kth_word(self, k):",
            "        assert k < self.root.prefix_count, f'{k}th string is not found'",
            "        current = self.root",
            "        string = []",
            "        while k >= 0:",
            "            for char, node in sorted(current.children.items()):",
            "                if node.prefix_count > k:",
            "                    current = node",
            "                    string.append(char)",
            "                    k -= current.word_count",
            "                    break",
            "                k -= node.prefix_count",
            "        return ''.join(string)",
            "",
            ""
        ],
        "description": [
            "Trie木クラス"
        ],
        "scope": "python"
    },
    "Zアルゴリズム": {
        "prefix": [
            "Lib_STr_Zalgorithm"
        ],
        "body": [
            "",
            "# Zアルゴリズム",
            "# S と S[i:]が接頭辞が一致する長さ",
            "# https://snuke.hatenablog.com/entry/2014/12/03/214243",
            "def z_algo(S):",
            "    n = len(S)",
            "    A = [n] + [0] * (n-1)",
            "    i, j = 1, 0",
            "    while i < n:",
            "        while i+j < n and S[j] == S[i+j]:",
            "            j += 1",
            "        A[i] = j",
            "        if not j:",
            "            i += 1",
            "            continue",
            "        k = 1",
            "        while n-i > k < j - A[k]:",
            "            A[i+k] = A[k]",
            "            k += 1",
            "        i += k; j -= k",
            "    return A",
            "",
            "s = input()",
            "ret = z_algo(s)",
            "",
            "# s = 'abcbcba'",
            "# ret = z_algo(s)",
            "# for i in range(len(s)):",
            "#     print(i, ret[i], s, s[i:])",
            "# 0 7 abcbcba abcbcba",
            "# 1 0 abcbcba bcbcba",
            "# 2 0 abcbcba cbcba",
            "# 3 0 abcbcba bcba",
            "# 4 0 abcbcba cba",
            "# 5 0 abcbcba ba",
            "# 6 1 abcbcba a",
            ""
        ],
        "description": [
            "Zアルゴリズム",
            "S と S[i:]が接頭辞が一致する長さ"
        ],
        "scope": "python"
    },
    "レーベンシュタイン距離": {
        "prefix": [
            "Lib_Str_レーベンシュタイン距離_Levenshtein_distance#"
        ],
        "body": [
            "",
            "#####################################",
            "# レーベンシュタイン距離 文字列の近似度",
            "# 文字削除・挿入・変更により文字列を一致させる最小の手順回数",
            "# distance: O(max(∣S∣,∣T∣))",
            "# 最小の手順回数がK以下",
            "# islowerK: O(min(∣S∣,∣T∣), K)",
            "#####################################",
            "# https://algo-method.com/tasks/315",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/1/DPL_1_E",
            "# https://atcoder.jp/contests/abc386/tasks/abc386_f",
            "",
            "class Levenshtein:",
            "    def __init__(self, S, T) -> None:",
            "        self.Type = type(S)",
            "        if self.Type == str:",
            "            S = list(S)",
            "            T = list(T)",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = len(S)",
            "        self.lt = len(T)",
            "        self.INF = max(self.ls, self.lt) + 1",
            "",
            "    def distance(self):",
            "        \"\"\"O(|S||T|)\"\"\"",
            "        self.dp = [[self.INF]*(self.lt+1) for _ in range(self.ls+1)]",
            "        dp = self.dp",
            "        for i in range(self.ls):",
            "            dp[i][0] = i",
            "        for j in range(self.lt):",
            "            dp[0][j] = j",
            "        for i in range(self.ls):",
            "            for j in range(self.lt):",
            "                if S[i] == T[j]:",
            "                    dp[i+1][j+1] = min(dp[i][j]  , dp[i+1][j]+1, dp[i][j+1]+1)",
            "                else:",
            "                    dp[i+1][j+1] = min(dp[i][j]+1, dp[i+1][j]+1, dp[i][j+1]+1)",
            "        self.length = self.dp[self.ls][self.lt]",
            "        return self.length",
            "",
            "    def restore(self):",
            "        # 復元",
            "        ret = []",
            "        i, j = self.ls, self.lt",
            "        dp = self.dp",
            "        while i and j:",
            "            # (i-1, j) -> (i, j) と更新されていた場合",
            "            if dp[i][j] == dp[i-1][j]:",
            "                i-=1   # DP の遷移を遡る",
            "            # (i, j-1) -> (i, j) と更新されていた場合",
            "            elif dp[i][j] == dp[i][j-1]:",
            "                j-=1   # DP の遷移を遡る",
            "            # (i-1, j-1) -> (i, j) と更新されていた場合",
            "            else:",
            "                ret.append(self.S[i-1])",
            "                # このとき s[i-1] == t[j-1] なので、t[j-1] + res でも OK",
            "                i-=1",
            "                j-=1   # DP の遷移を遡る",
            "        ret = ret[::-1]",
            "        if self.Type == str: ret = ''.join(ret)",
            "        return ret",
            "",
            "    def islowerK(self, K):",
            "        \"\"\"distance <= K\"\"\"",
            "        \"\"\"O(min(|S|, |T|), K)\"\"\"",
            "        ls, lt, S, T = self.ls, self.lt, self.S, self.T",
            "        if ls > lt: ls, lt, S, T = lt, ls, T, S",
            "        if lt - ls > K: return False",
            "",
            "        dp = [self.INF] * K + list(range(K+1))",
            "        for i in range(1, ls+1):",
            "            ndp = [self.INF] * (2*K+1)",
            "            for d in range(2*K+1):",
            "                j = i + d - K",
            "                if j < 0: continue",
            "                if j > lt: break",
            "                if j>0:",
            "                    ndp[d] = min(ndp[d], dp[d] + (S[i-1] != T[j-1]))",
            "                if j-i<K:",
            "                    ndp[d] = min(ndp[d], dp[d+1] + 1)",
            "                if j>0 and j-i>-K:",
            "                    ndp[d] = min(ndp[d], ndp[d-1] + 1)",
            "            dp = ndp",
            "",
            "        return dp[lt-ls+K] <= K",
            "",
            "#####################",
            "K = int(input())",
            "S = input()",
            "T = input()",
            "",
            "ldiff = Levenshtein(S, T)",
            "print(ldiff.distance())",
            "print('Yes' if ldiff.islowerK(K) else 'No')",
            "",
            ""
        ],
        "description": [
            "Lib_レーベンシュタイン距離"
        ],
        "scope": "python"
    },
    "回文": {
        "prefix": [
            "Lib_Str_回文_Palindrome"
        ],
        "body": [
            "# https://atcoder.jp/contests/indeednow-finalb-open/tasks/indeednow_2015_finalb_c",
            "",
            "class Palindrome:",
            "    def __init__(self, S):",
            "        self.L = len(S)",
            "        self.S = S",
            "        self.DL = 2 * self.L - 1",
            "        _S = [0] * self.DL; _S[::2] = S",
            "        self.DS = _S",
            "        self.Mresult = self.manacher()",
            "",
            "    def manacher(self):",
            "        # 偶数長含めた回文の長さを求める",
            "        # R[2*i] = L: S[i]を中心とする奇数長の最大回文の半径",
            "        # R[2*i+1] = L: S[i:i+2]を中心とする偶数長の最大回文の半径",
            "        # ダミー文字を挟むが、各 R[i] は実際の回文の文字列長と一致する",
            "        L = self.DL; _S= self.DS",
            "        R = [0] * L; i = 0; j = 0",
            "        while i < L:",
            "            while i >= j and i + j < L and _S[i-j] == _S[i+j]: j += 1",
            "            R[i] = j; k = 1",
            "            while (i >= k) and (i + k < L) and (k + R[i-k] < j):",
            "                R[i + k] = R[i - k]; k += 1",
            "            i += k; j -= k",
            "        return R",
            "",
            "    def OddStrRadius(self, c):",
            "        pos = 2*c",
            "        if pos >= self.DL: return -1",
            "        r = (self.Mresult[pos] + 1) // 2",
            "        return r",
            "",
            "    def EvenStrRadius(self, c):",
            "        pos = 2*c + 1",
            "        if pos >= self.DL: return -1",
            "        r = self.Mresult[pos] // 2",
            "        return r",
            "",
            "    def isPalindrome(self, l, r):",
            "        \"\"\" 開区間[l,r)が回文か\"\"\"",
            "        d = (r-l+1)//2",
            "        c = l+d-1",
            "        if (r-l)%2:",
            "            return d <= self.OddStrRadius(c)",
            "        return d <= self.EvenStrRadius(c)",
            "",
            "",
            "n = int(input())",
            "S = input()",
            "",
            "pd = Palindrome(S)",
            ""
        ],
        "description": [
            "回文クラス"
        ],
        "scope": "python"
    }
}